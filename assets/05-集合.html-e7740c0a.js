const e=JSON.parse('{"key":"v-314d05ce","path":"/study/java/javaSE/05-%E9%9B%86%E5%90%88.html","title":"集合Collection","lang":"zh-CN","frontmatter":{"category":"基础","tag":["array","java"],"description":"集合Collection Collection 单列 List: 有序,允许重复 Arraylist： Object数组,线程不安全 Vector： Object数组,方法全部使用Synchronized修饰线程安全,效率低 LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环),线程不安全 Set: 不允许重复 HashSet（⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap来实现的。 TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树) Map: 双列键值对 HashMap： JDK1.8之前HashMap由数组+链表组成的。JDK1.8以后在解决哈希冲突时有了较⼤的变化， 当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是由数组和链表或红⿊树组成。另外，LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链 表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问 顺序相关逻辑。 Hashtable： 数组+链表组成的.方法全部使用Synchronized修饰线程安全,效率低. TreeMap： 红⿊树（⾃平衡的排序⼆叉树） 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。 Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list， 不可对其进行添加或者删除元素的操作。 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是和返回类型完全一 致、长度为 0 的空数组。 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。 等于 0，动态创建与 size 相同的数组，性能最好。 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。","head":[["meta",{"property":"og:url","content":"https://zhaoxin1998.github.io/debugKing-github.io/debugKing-github.io/study/java/javaSE/05-%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"DebugKing"}],["meta",{"property":"og:title","content":"集合Collection"}],["meta",{"property":"og:description","content":"集合Collection Collection 单列 List: 有序,允许重复 Arraylist： Object数组,线程不安全 Vector： Object数组,方法全部使用Synchronized修饰线程安全,效率低 LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环),线程不安全 Set: 不允许重复 HashSet（⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap来实现的。 TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树) Map: 双列键值对 HashMap： JDK1.8之前HashMap由数组+链表组成的。JDK1.8以后在解决哈希冲突时有了较⼤的变化， 当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是由数组和链表或红⿊树组成。另外，LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链 表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问 顺序相关逻辑。 Hashtable： 数组+链表组成的.方法全部使用Synchronized修饰线程安全,效率低. TreeMap： 红⿊树（⾃平衡的排序⼆叉树） 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。 Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list， 不可对其进行添加或者删除元素的操作。 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是和返回类型完全一 致、长度为 0 的空数组。 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。 等于 0，动态创建与 size 相同的数组，性能最好。 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-18T08:24:49.000Z"}],["meta",{"property":"article:author","content":"DebugKing"}],["meta",{"property":"article:tag","content":"array"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2023-07-18T08:24:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集合Collection\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-18T08:24:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DebugKing\\",\\"url\\":\\"https://github.com/zhaoxin1998\\",\\"email\\":\\"1778524294@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"方法","slug":"方法","link":"#方法","children":[{"level":3,"title":"正确的将数组转换为ArrayList","slug":"正确的将数组转换为arraylist","link":"#正确的将数组转换为arraylist","children":[]}]},{"level":2,"title":"遍历","slug":"遍历","link":"#遍历","children":[]},{"level":2,"title":"方法","slug":"方法-1","link":"#方法-1","children":[]},{"level":2,"title":"遍历","slug":"遍历-1","link":"#遍历-1","children":[{"level":3,"title":"循环","slug":"循环","link":"#循环","children":[]},{"level":3,"title":"迭代器","slug":"迭代器","link":"#迭代器","children":[]}]},{"level":2,"title":"HashMap底层实现","slug":"hashmap底层实现","link":"#hashmap底层实现","children":[{"level":3,"title":"jdk1.8之前","slug":"jdk1-8之前","link":"#jdk1-8之前","children":[]},{"level":3,"title":"jdk1.8之前","slug":"jdk1-8之前-1","link":"#jdk1-8之前-1","children":[]}]},{"level":2,"title":"ConcurrentHashMap 和 Hashtable 实现线程安全的区别","slug":"concurrenthashmap-和-hashtable-实现线程安全的区别","link":"#concurrenthashmap-和-hashtable-实现线程安全的区别","children":[]}],"git":{"createdTime":1689652609000,"updatedTime":1689668689000,"contributors":[{"name":"zhaoxin1998","email":"1778524294@qq.com","commits":2}]},"filePathRelative":"study/java/javaSE/05-集合.md","localizedDate":"2023年7月18日","excerpt":"<h1> 集合Collection</h1>\\n<ul>\\n<li>Collection 单列\\n<ul>\\n<li>List: 有序,允许重复\\n<ul>\\n<li>Arraylist： Object数组,线程不安全</li>\\n<li>Vector： Object数组,方法全部使用Synchronized修饰线程安全,效率低</li>\\n<li>LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环),线程不安全</li>\\n</ul>\\n</li>\\n<li>Set: 不允许重复\\n<ul>\\n<li>HashSet（⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素</li>\\n<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap来实现的。</li>\\n<li>TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>Map: 双列键值对\\n<ul>\\n<li>HashMap： JDK1.8之前HashMap由数组+链表组成的。JDK1.8以后在解决哈希冲突时有了较⼤的变化，<br>\\n当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间</li>\\n<li>LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是由数组和链表或红⿊树组成。另外，LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链<br>\\n表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问<br>\\n顺序相关逻辑。</li>\\n<li>Hashtable： 数组+链表组成的.方法全部使用Synchronized修饰线程安全,效率低.</li>\\n<li>TreeMap： 红⿊树（⾃平衡的排序⼆叉树）</li>\\n</ul>\\n</li>\\n<li>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code>方法，而不是 <code>size()==0</code> 的方式。</li>\\n<li>Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，<br>\\n不可对其进行添加或者删除元素的操作。</li>\\n<li>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是和返回类型完全一<br>\\n致、长度为 0 的空数组。\\n<ul>\\n<li>直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</li>\\n<li>等于 0，动态创建与 size 相同的数组，性能最好。</li>\\n<li>大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</li>\\n<li>等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</li>\\n<li>大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true,"copyright":{"author":"Mr.debugKing","license":"MIT"},"readingTime":{"minutes":8.55,"words":2566}}');export{e as data};
