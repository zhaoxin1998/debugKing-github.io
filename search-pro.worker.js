const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":82,\"nextId\":82,\"documentIds\":{\"0\":\"v-d7188082\",\"1\":\"v-d7188082#知识脑图-转载\",\"2\":\"v-5fff315a\",\"3\":\"v-5fff315a#异常处理原则\",\"4\":\"v-3a4b1ea8\",\"5\":\"v-6f88255e\",\"6\":\"v-22146494\",\"7\":\"v-22146494#calendar对象获取日历\",\"8\":\"v-22146494#_1-创建calendar对象\",\"9\":\"v-22146494#_2-常用方法\",\"10\":\"v-22146494#date对象\",\"11\":\"v-22146494#_1-常用方法\",\"12\":\"v-22146494#_2-simpledateformat-格式化\",\"13\":\"v-22146494#jdk8新增-java-time包\",\"14\":\"v-22146494#_1-clock-时钟\",\"15\":\"v-22146494#_2-instant-时刻-时间戳\",\"16\":\"v-22146494#_3-localxxx-本地时间\",\"17\":\"v-22146494#_4-datetimeformatter格式化\",\"18\":\"v-314d05ce\",\"19\":\"v-314d05ce#方法\",\"20\":\"v-314d05ce#正确的将数组转换为arraylist\",\"21\":\"v-314d05ce#遍历\",\"22\":\"v-314d05ce#方法-1\",\"23\":\"v-314d05ce#遍历-1\",\"24\":\"v-314d05ce#循环\",\"25\":\"v-314d05ce#迭代器\",\"26\":\"v-314d05ce#hashmap底层实现\",\"27\":\"v-314d05ce#jdk1-8之前\",\"28\":\"v-314d05ce#jdk1-8之前-1\",\"29\":\"v-314d05ce#concurrenthashmap-和-hashtable-实现线程安全的区别\",\"30\":\"v-27694f64\",\"31\":\"v-27694f64#stirng方法\",\"32\":\"v-27694f64#常用方法\",\"33\":\"v-27694f64#stringbuffer-stringbuilder方法\",\"34\":\"v-27694f64#常用方法-1\",\"35\":\"v-27694f64#string不可变的好处\",\"36\":\"v-27694f64#判断字符串是否为数字\",\"37\":\"v-27694f64#用java自带的函数\",\"38\":\"v-27694f64#使用lang3下的包下stringutils类的方法isnumeric\",\"39\":\"v-27694f64#用正则表达式\",\"40\":\"v-4e58a31c\",\"41\":\"v-4e58a31c#分类\",\"42\":\"v-4e58a31c#基类\",\"43\":\"v-4e58a31c#既然有了字节流-为什么还要有字符流\",\"44\":\"v-4e58a31c#文件读取写入\",\"45\":\"v-4e58a31c#file类\",\"46\":\"v-4e58a31c#常用方法\",\"47\":\"v-9c7bf3ce\",\"48\":\"v-9c7bf3ce#线程创建\",\"49\":\"v-9c7bf3ce#继承thread类\",\"50\":\"v-9c7bf3ce#实现runnable接口\",\"51\":\"v-9c7bf3ce#实现callable接口\",\"52\":\"v-9c7bf3ce#thread方法\",\"53\":\"v-9c7bf3ce#线程状态-thread-state\",\"54\":\"v-9c7bf3ce#线程优先级priority\",\"55\":\"v-9c7bf3ce#守护线程daemon\",\"56\":\"v-9c7bf3ce#停止线程\",\"57\":\"v-9c7bf3ce#threadlocal-数据隔离\",\"58\":\"v-9c7bf3ce#threadlocal-适用于如下两种场景\",\"59\":\"v-9c7bf3ce#threadlocal-原理\",\"60\":\"v-9c7bf3ce#threadlocal-内存泄露问题\",\"61\":\"v-9c7bf3ce#线程复用问题\",\"62\":\"v-9c7bf3ce#线程同步\",\"63\":\"v-9c7bf3ce#synchronized-同步锁-可重入锁-悲观锁\",\"64\":\"v-9c7bf3ce#实现原理\",\"65\":\"v-9c7bf3ce#修饰代码块-jvm会在字节码文件中在同步代码块开始位置插入-monitorenter-进入监控-在同步代码块结束位置插入monitorexit-退出监控-指-令-当执行monitorenter-指令时-线程试图获取锁也就是获取-monitor-monitor-对象存在于每个java对象的对象头中-当计数器为0则可以成功获取-获取后将锁-计数器加1。相应的在执行monitorexit-指令后-将锁计数器减一-当计数器为0-时表明锁被释放。如果获取对象锁失败-那当前线程就要阻塞等待-直到锁被另-外㇐个线程释放为止。\",\"66\":\"v-9c7bf3ce#修饰方法-jvm会在字节码文件中方法标识符中添加一个-acc-synchronized标识-执行线程需要先获得monitor锁-然后开始执行方法-方-法执行之后再释放monitor锁-当方法不管是正常return还是抛出异常都会释放-对应的monitor锁。\",\"67\":\"v-9c7bf3ce#锁的范围\",\"68\":\"v-9c7bf3ce#使用方式\",\"69\":\"v-9c7bf3ce#synchronized-优化\",\"70\":\"v-9c7bf3ce#lock\",\"71\":\"v-63048f52\",\"72\":\"v-63048f52#jdk内置注解\",\"73\":\"v-63048f52#元-meta-注解\",\"74\":\"v-63048f52#自定义注解\",\"75\":\"v-63048f52#获取class对象\",\"76\":\"v-63048f52#class类的方法\",\"77\":\"v-63048f52#获取方法泛型信息\",\"78\":\"v-63048f52#获取注解信息\",\"79\":\"v-3e2c079e\",\"80\":\"v-3d6b890d\",\"81\":\"v-74fcd9ee\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,9],\"1\":[3],\"2\":[1,2],\"3\":[1,108],\"4\":[1,118],\"5\":[1,87],\"6\":[1],\"7\":[1,3],\"8\":[2,10],\"9\":[2,56],\"10\":[1,37],\"11\":[2,37],\"12\":[3,66],\"13\":[3],\"14\":[3,12],\"15\":[5,53],\"16\":[3,46],\"17\":[2,30],\"18\":[1,174],\"19\":[1,63],\"20\":[1,30],\"21\":[1,90],\"22\":[1,16],\"23\":[1],\"24\":[1,43],\"25\":[1,11],\"26\":[1],\"27\":[2,32],\"28\":[2,6],\"29\":[4,89],\"30\":[1],\"31\":[1,17],\"32\":[1,88],\"33\":[2,13],\"34\":[1,15],\"35\":[1,61],\"36\":[1],\"37\":[1,21],\"38\":[2,9],\"39\":[1,16],\"40\":[2],\"41\":[1,5],\"42\":[1,11],\"43\":[3,11],\"44\":[1,60],\"45\":[1],\"46\":[1,19],\"47\":[1],\"48\":[1,9],\"49\":[1,49],\"50\":[1,53],\"51\":[1,71],\"52\":[1,40],\"53\":[4,10],\"54\":[1,6],\"55\":[1,11],\"56\":[1,6],\"57\":[2,37],\"58\":[2,3],\"59\":[2,15],\"60\":[2,34],\"61\":[1,12],\"62\":[1],\"63\":[4],\"64\":[1],\"65\":[26],\"66\":[11],\"67\":[1,16],\"68\":[1,22],\"69\":[2,55],\"70\":[1,1],\"71\":[2],\"72\":[1,13],\"73\":[3,19],\"74\":[1,50],\"75\":[1,14],\"76\":[1,75],\"77\":[1,20],\"78\":[1,16],\"79\":[1,224],\"80\":[3],\"81\":[1]},\"averageFieldLength\":[1.9634146341463414,38.93801820602734],\"storedFields\":{\"0\":{\"h\":\"技术栈\",\"t\":[\"实话实说，我不是一个能够静下心来踏踏实实做技术的人，虽然身边不乏有对技术沉迷且执着的人，但我很少能够受他们所影响，唯一庆幸的是，在一位同乡挚友的鞭策下，我才愿意抽出时间和精力，对以往的知识体系进行系统的回顾与记录。\"]},\"1\":{\"h\":\"知识脑图（转载）\"},\"2\":{\"h\":\"异常\",\"t\":[\"异常用于解决一下程序无法掌握但又必须面对的情况.\"]},\"3\":{\"h\":\"异常处理原则\",\"t\":[\"尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常\",\"不要生吞（swallow）异常,捕获异常后不要不做任何操作或直接e.printStackTrace();输出堆栈轨迹信息\",\"try-catch 代码段会产生额外的性能开销，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码\",\"Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。\",\"父类能够捕获子类异常\",\"class Annoyance extends Exception {} class Sneeze extends Annoyance {} class Human { public static void main(String[] args) throws Exception { try { try { throw new Sneeze(); } catch ( Annoyance a ) { System.out.println(\\\"Caught Annoyance\\\"); throw a; } } catch ( Sneeze s ) { System.out.println(\\\"Caught Sneeze\\\"); return ; } finally { System.out.println(\\\"Hello World!\\\"); } } } 输出: Caught Annoyance Caught Sneeze //使用的是父类的引用，但实际上是子类的对象,所以可以捕获 Hello World! \",\"ArithmeticException（算术异常）\",\"ClassCastException （类转换异常）\",\"IllegalArgumentException （非法参数异常）\",\"IndexOutOfBoundsException （下标越界异常）\",\"NullPointerException （空指针异常）\",\"InterruptedException: 中断异常\",\"ClassNotFoundException: 类未找到\",\"NoClassDefFoundError: 类已加载但运行时找不到\",\"检查异常: 编译器要求你必须处置的异常。 \",\"如IOException、SQLException等\",\"非检查异常: RuntimeException与其子类，以及错误（Error）\",\"JDK7提供的try-catch-finally简洁版,用于自动关闭连接,更好处理异常,减少编码量等\",\"try(BufferedReader br = new BufferedReader(...)){//try-with-resources会自动关闭流对象 //do some }catch(IOException | XException e){ //multiple catch //.... } \",\"自定义非检查异常: extends RuntimeException\",\"自定义检查异常: extends Exception\",\"自定义异常的考虑\",\"是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。\",\"在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。\"]},\"4\":{\"h\":\"枚举Enum\",\"t\":[\"enum Color { // 常量会被转换为当前枚举对象,对象名为常量名 RED, GREEN, BLUE; } public class Test { // 执行输出结果 public static void main(String[] args) { Color c1 = Color.RED; System.out.println(c1); } } \",\"枚举值必须在枚举类的第一行显式地列出\",\"每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。上面的枚举类 Color 转化在内部类实现：\",\"class Color { public static final Color RED = new Color(); public static final Color BLUE = new Color(); public static final Color GREEN = new Color(); } \",\"enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。\",\"values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：\",\"values() 返回枚举类中所有的值。\",\"ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。\",\"valueOf()方法返回指定字符串值的枚举常量。不存在的会报错 IllegalArgumentException\",\"重写toString()方法,改变输出的值\",\"enum Color { RED, GREEN, BLUE; } public class MyClass { public static void main(String[] args) { for (Color myVar : Color.values()) { System.out.println(myVar); } } } \",\"枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。\",\"枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。\",\"enum Color { RED, GREEN, BLUE{ public void colorInfo() { System.out.println(\\\"Universal BLUE\\\"); } }; // 构造函数 private Color() { System.out.println(\\\"Constructor called for : \\\" + this.toString()); } public void colorInfo() { System.out.println(\\\"Universal Color\\\"); } } public class Test { // 输出 public static void main(String[] args) { Color c1 = Color.RED; System.out.println(c1); c1.colorInfo(); Color c2 = Color.BLUE; c2.colorInfo(); } } // 输出 Constructor called for : RED Constructor called for : GREEN Constructor called for : BLUE RED Universal Color Universal BLUE \",\"抽象方法\",\"enum Type{ A{ public String getType() { return \\\"A\\\"; } },B { @Override public String getType() { return \\\"B\\\"; } },C { @Override public String getType() { return \\\"C\\\"; } },D { @Override public String getType() { return \\\"D\\\"; } }; public abstract String getType(); } \",\"带参数的构造函数\",\"public enum WeekEnum { // 因为已经定义了带参数的构造器，所以在列出枚举值时必须传入对应的参数 SUNDAY(\\\"星期日\\\"), MONDAY(\\\"星期一\\\"), TUESDAY(\\\"星期二\\\"), WEDNESDAY(\\\"星期三\\\"), THURSDAY(\\\"星期四\\\"), FRIDAY(\\\"星期五\\\"), SATURDAY(\\\"星期六\\\"); // 定义一个 private 修饰的实例变量 private String date; // 定义一个带参数的构造器，枚举类的构造器只能使用 private 修饰 private WeekEnum(String date) { this.date = date; } // 定义 get set 方法 public String getDate() { return date; } public void setDate(String date) { this.date = date; } } \"]},\"5\":{\"h\":\"数组\",\"t\":[\"数组创建后,它的大小就是固定的\",\"int[] nums0 = {1,2,3,4,5}; //静态初始化 String[] array2=new String[]{\\\"黄渤\\\",\\\"张艺兴\\\",\\\"孙红雷\\\",\\\"小猪\\\",\\\"牙哥\\\",\\\"黄磊\\\"}; int[] nums1 = new int[size]; //动态初始化(默认值为基本类型默认值值) nums.length; // 获取数组的长度 int[][] array={{1,2},{2,3},{3,4}} array.length; //返回行数即3, array[0].length; //返回某行列数即2 \",\"Arrays.asList(\\\"1\\\",\\\"2\\\",\\\"3\\\"); //数组转list,传递的数组必须是对象数组，而不是基本类型。 // 如果传入基本数据类型的数组,得到的List只有一个元素,为该数组 // 返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,无add等方法 Arrays.asList(array1).contains(\\\"a\\\"); //判断数组中是否包含a Arrays.toString(a); //转字符串 Arrays.sort(a); //升序 Arrays.sort(arr,Collections.reverseOrder()); // 倒序,数组必须是包装类型 Arrays.sort(a,fromIndex,toIndex); //范围升序,含头不含尾 Arrays.binarySearch(e,\\\"c\\\") //二分查找字符c在数组的位置,要先排序 Arrays.fill(a,0); //将数组a中元素全部填充为0 Arrays.fill(a,2,4,0); // 从0数[2,4)填充为0 Arrays.copyOf(h, 6); // 复制的长度 Arrays.copyOfRange(h, 6, 11); // 指定索引复制 \",\"当一个数组中大部分元素为0或同一个值时,可以使用稀疏数组来保存该数组节省空间.\",\"稀疏数组是一个n行3列的二维数组 \",\"第一行记录原始数组的行,列,有效值的个数\",\"剩余行记录有效值在原始数组的位置和值\"]},\"6\":{\"h\":\"日期与时间\"},\"7\":{\"h\":\"Calendar对象获取日历\",\"t\":[\"Calendar是Java中常用的时间处理工具之一,它提供了很多日历类型常见方法.\"]},\"8\":{\"h\":\"1.创建Calendar对象\",\"t\":[\" //Calendar是一个抽象类，不能直接创建对象，可以通过getInstance()方法获取实例 Calendar calendar = Calendar.getInstance(); //默认是当前日期 \"]},\"9\":{\"h\":\"2.常用方法\",\"t\":[\" //2.1 获取年 System.out.println(\\\"年：\\\"+calendar.get(Calendar.YEAR)); //2.2 获取月 //月份从0开始，0表示1月份，1表示2月份，以此类推 System.out.println(\\\"月：\\\"+(calendar.get(Calendar.MONTH)+1)); //2.3 获取日 System.out.println(\\\"日：\\\"+calendar.get(Calendar.DAY_OF_MONTH)); //2.4 获取时 System.out.println(\\\"时：\\\"+calendar.get(Calendar.HOUR_OF_DAY)); //2.5 获取分 System.out.println(\\\"分：\\\"+calendar.get(Calendar.MINUTE)); //2.6 获取秒 System.out.println(\\\"秒：\\\"+calendar.get(Calendar.SECOND)); //2.7 获取星期几 //星期日：1，星期一：2，星期二：3，星期三：4，星期四：5，星期五：6，星期六：7 System.out.println(\\\"星期几：\\\"+calendar.get(Calendar.DAY_OF_WEEK)); 输出： 年：2024 月：1 日：8 时：15 分：51 秒：35 星期几：2 \"]},\"10\":{\"h\":\"Date对象\",\"t\":[\"java.util 包提供了 Date 类来封装当前的日期和时间\",\"Date 类提供两个构造函数来实例化 Date 对象->Date( ) Date(long millisec)\",\" Date date2= new Date(); System.out.println(date2); //参数表示1970-01-01 00:00:00到指定时间的毫秒数 Date date1 = new Date(14686531L); System.out.println(date1); 输出： Mon Jan 08 16:12:34 CST 2024 Thu Jan 01 12:04:46 CST 1970 \"]},\"11\":{\"h\":\"1.常用方法\",\"t\":[\" boolean after(Date when) //测试此日期是否在指定日期之后。 boolean before(Date when) //测试此日期是否在指定日期之前。 long getTime() //返回一个表示此对象表示的日期的毫秒数。 Date getTime() //返回一个表示此 Calendar 时间值（从历元到现在的毫秒偏移量）的 Date 对象。 void setTime(Date date) //用来对 Calendar 的时间值进行设置。 long getTimeInMillis() //返回此 Calendar 的时间值（从历元至现在的毫秒偏移量）。 void setTimeInMillis(long millis) //用来对 Calendar 的时间值进行设置。 long getTimeInMillis() //返回此 Calendar 的时间值，以毫秒为单位。 int get(int field) //返回此 Calendar 的时间值，以毫秒为单位。 void set(int field, int value) //用给定的日历字段值设置日历的当前时间值。 void set(int year, int month, int date) //用给定的日历字段值设置日历的当前时间值。 \"]},\"12\":{\"h\":\"2.SimpleDateFormat 格式化\",\"t\":[\"进行date类日期的加,减,比较操作可以将其转换为毫秒级的long类型(时间戳)在 进行操作\",\"SimpleDateFormat 不是线程安全的,可将 其限制在 ThreadLocal 中.也可 使用joda-time库(jdk8将其引入并修改为java.time包)\",\" Date now = new Date() ; SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"HH:mm:ss\\\"); String time1 = dateFormat.format(now); //date转格式化stirng Date time =dateFormat.parse(time1); //String转Date time.getTime(); //时间转换成毫秒级的long型（时间戳） // 计算日期间隔 public static String getDatePoor(Date endDate, Date nowDate) { long nd = 1000 * 24 * 60 * 60; long nh = 1000 * 60 * 60; long nm = 1000 * 60; // long ns = 1000; // 获得两个时间的毫秒时间差异 long diff = endDate.getTime() - nowDate.getTime(); // 计算差多少天 long day = diff / nd; // 计算差多少小时 long hour = diff % nd / nh; // 计算差多少分钟 long min = diff % nd % nh / nm; // 计算差多少秒//输出结果 // long sec = diff % nd % nh % nm / ns; return day + \\\"天\\\" + hour + \\\"小时\\\" + min + \\\"分钟\\\"; } \"]},\"13\":{\"h\":\"jdk8新增 java.time包\"},\"14\":{\"h\":\"1.Clock 时钟\",\"t\":[\"Clock获取指定时区的当前日期,时间\",\" Clock clock = Clock.ststemUTC(); //获取utc时区 clock.instant(); //获取utc时区转换的当前时间 clock.millis(); //获取utc时区转换的毫秒数 \"]},\"15\":{\"h\":\"2.Instant 时刻(时间戳)\",\"t\":[\"Instant类表示一个具体的时刻可以精确到纳秒(即时间戳\",\" Instant timestamp = Instant.now(); // 获取当前时间 Instant instant2 = Instant.ofEpochMilli(date.getTime()); //根据毫秒值或者date转换为instant Instant parse = Instant.parse(\\\"1970-01-01T01:00:00Z\\\"); //必须符合 UTC格式的字符串 Instant oneHourLater = Instant.now().plusHours(1); // 加法 +1小时 Instant plus = instant.plus(Duration.ofHours(5).plusMinutes(10)); //加了5小时10分钟 Instant instant6 = instant.minusSeconds(60 * 60 * 5); // 减法 int i = instant.compareTo(instant6); // 相等 0 大于1 小于-1 boolean after = instant.isAfter(instant6); //前者在后者之后返回true,反之false boolean before = instant.isBefore(instant6); //与上面相反 \"]},\"16\":{\"h\":\"3.LocalXXX 本地时间\",\"t\":[\"新引入的类LocalDate、LocalTime和LocalDateTime，分别处理日期、时间和日期时间 如果想用这三个类接收数据库日期，那么使用的mysql-connectorjava版本不能低于5.1.37，即数据库的驱动版本不低于4.2\",\" //实例化方式 //1.使用now()方法 LocalDate date = LocalDate.now(); //获取当前日期 LocalDate date = LocalDate.now(clock); //获取clock对应日期 //2.使用of()方法指定时间 LocalDateTime birthday = LocalDateTime.of(1994,4,18,4,56,32); //方法 getXxxx() //获取xxx with() //通用 withxxx(int) //调整时间，返回新设置的时间 plusXXX() //返回加上对应值的时间 minusxxx() //返回减去对应值的时间 lengthOfYear() // 获取某年的天数 \"]},\"17\":{\"h\":\"4.DateTimeFormatter格式化\",\"t\":[\"线程安全\",\" //三种实例化方式 //使用常量创建 DateTimeFormatter df1 =DateTimeFormatter.ISO_DATE_TIME; df1.format(date); //格式化 df1.parse(); //解析 string转日期 //使用Long类型风格的FormatStyle.FULL FormatStyle.LONG FormatStyle.MEDIUM FormatStyle.SHORT DateTimeFormatter df2=DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL) //自定义格式 DateTimeFormatter df6=DateTimeFormatter.ofPattern(\\\"HH:mm:ss\\\") \"]},\"18\":{\"h\":\"集合Collection\",\"t\":[\"Collection 单列 \",\"List: 有序,允许重复 \",\"Arraylist： Object数组,线程不安全\",\"Vector： Object数组,方法全部使用Synchronized修饰线程安全,效率低\",\"LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环),线程不安全\",\"Set: 不允许重复 \",\"HashSet（⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素\",\"LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap来实现的。\",\"TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)\",\"Map: 双列键值对 \",\"HashMap： JDK1.8之前HashMap由数组+链表组成的。JDK1.8以后在解决哈希冲突时有了较⼤的变化， 当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间\",\"LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是由数组和链表或红⿊树组成。另外，LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链 表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问 顺序相关逻辑。\",\"Hashtable： 数组+链表组成的.方法全部使用Synchronized修饰线程安全,效率低.\",\"TreeMap： 红⿊树（⾃平衡的排序⼆叉树）\",\"判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。\",\"Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list， 不可对其进行添加或者删除元素的操作。\",\"使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是和返回类型完全一 致、长度为 0 的空数组。 \",\"直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。\",\"等于 0，动态创建与 size 相同的数组，性能最好。\",\"大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。\",\"等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。\",\"大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。\",\"List<String> list = new ArrayList<>(2); list.add(\\\"guan\\\"); list.add(\\\"bao\\\"); // 数组大小 等于 0，动态创建与 size 相同的数组，性能最好 String[] array = list.toArray(new String[0]); \",\"ArrayList如何动态扩容: 它的底层是一个动态数组(默认容量10),会在add()时进行判断,如果已满则自动扩容1.5倍 \",\"具体为int newCapacity= oldCapacity + (Capacity>>1); \",\"扩容操作将原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\",\"不要在 foreach 循环里进行元素的 remove/add 操作,会抛出ConcurrentModificationException异常。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\",\"List<String> list = new ArrayList<>(); list.add(\\\"1\\\"); list.add(\\\"2\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String item = iterator.next(); if (删除元素的条件) { iterator.remove(); } } \",\"使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\"]},\"19\":{\"h\":\"方法\",\"t\":[\"List.of(\\\"hello\\\", \\\"world\\\"); //创建不可变的list list.contains(\\\"苹果\\\"); //判断集合中是否存在苹果 arrayList.add(\\\"1\\\"); //添加元素 arrayList.add(0,\\\"2\\\"); //在指定位置添加元素 arrayList.addAll(Collection<? extends E> c) //将集合中所有元素插入该集合末尾 arrayList.addAll(int index, Collection<? extends E> c) //将集合中所有元素插入该集合指定位置 arrayList.get(i) //获取元素 arrayList.remove(2); //删除指定位置上的元素 arrayList.remove(new Object()); //删除指定对象 arrayList.removeAll(Collection<?> c) //从此列表中删除指定集合中包含的所有元素。 arrayList.clear(); //清空ArrayList arrayList.isEmpty() //判断ArrayList是否为空 arrayList.size() //大小 arrayList.indexOf() //获取对象位置(有相同引用的对象 返回最前的下标) arrayList.set(index, new Object()); //替换 指定下标的对象 linkedList.addFirst(0); // 添加元素到列表开头 linkedList.addLast(3); // 添加元素到列表结尾 linkedList.getFirst() linkedList.getLast() linkedList.removeFirst() linkedList.removeLast() linkedList.indexOf(3) //返回此列表中首次出现的指定元素的索引 linkedList.lastIndexOf(3); // 返回此列表中最后出现的指定元素的索引 \"]},\"20\":{\"h\":\"正确的将数组转换为ArrayList\",\"t\":[\"// 最简便的方法 List list = new ArrayList<>(Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\")) // 使用 Java8 的Stream Integer [] myArray = { 1, 2, 3 }; List myList = Arrays.stream(myArray).collect(Collectors.toList()); //基本类型也可以实现转换（依赖boxed的装箱操作） int [] myArray2 = { 1, 2, 3 }; List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); \"]},\"21\":{\"h\":\"遍历\",\"t\":[\"List<String> items = new ArrayList<>(); // jdk8之前 for(String item : items){ System.out.println(item); } // jdk8之后 items.forEach(item->System.out.println(item)); // 遍历的同时要进行修改使用迭代器 \",\"HashSet 的本质就是只有键的 HashMap\",\"HashSet判断对象是否存在,先执行对象的hashcode()方法,若无重复则对象不存在.若重复则调用equals()方法判断是否真的相同\",\"HashMap创建时默认的初始化容量(1<<4 即16)和加载因子(0.75f).阀值的计算公式是 容量 * 加载因子,达到阀值则扩容为原来的两倍\",\"HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默 认值（16）即可。initialCapacity = (需要存储的元素个数 / 负载因子) + 1,HashMap底层会通过tableSizeFor() ⽅ 法将initialCapacity扩充为2的幂次⽅⼤⼩\",\"Hash的值大约40亿个( -(2 ^ 31)~(2 ^ 31 - 1)),内存放不下,因此要对hash的⻓度取模运算，得到的余数才能⽤来要存放 的位置也就是对应的数组下标。而取余(%)操作中如果除数是2的幂次则等价于与其除数减⼀的与(&)操作(hash%n 等价于 (n-1)&hash).因为二进制操作比%运算效率高,这就解释了 HashMap 的⻓度 为什么是2的幂次⽅。\",\"HashTable 是线程安全的；HashTable 内部的⽅法 基本都经过 synchronized 修饰。默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。\",\"将数据put到HashMap后,HashMap会根据key的hashcode()从小到大排序. \",\"而1的hashcode为1,2的hashcode为2,只要把key设置为数字,遍历时就是从小到大输出了.\"]},\"22\":{\"h\":\"方法\",\"t\":[\"map.containsKey() // 判断是否包含某个Key值 map.containsValue() // 判断是否包含某个Value值。 map.put(\\\"san\\\", \\\"张三\\\"); //键不能重复，值可以重复 map.get(\\\"si\\\") map.remove(\\\"key\\\"); map.size() \"]},\"23\":{\"h\":\"遍历\"},\"24\":{\"h\":\"循环\",\"t\":[\"使用 entrySet/keySet/values返回集合对象时,不可以对其进行添加元素操作,不然会报 UnsupportedOperationException 异常\",\" // foreach map.forEach((k,v)->System.out.println(\\\"key : \\\" + k + \\\" value : \\\" + v)); // entrySet是 键-值 对的集合，entrySet中的类型是Map.Entry for (Map.Entry<String, String> entry : map.entrySet()) { System.out.println(\\\"key= \\\" + entry.getKey() + \\\" and value= \\\" + entry.getValue()); } // keySet是键的集合，Set里面的类型即key的类型 for (String key : map.keySet()) { System.out.println(\\\"key= \\\"+ key + \\\" and value= \\\" + map.get(key)); } // values是值的集合 for (String v : map.values()) { System.out.println(\\\"value= \\\" + v); } \"]},\"25\":{\"h\":\"迭代器\",\"t\":[\"使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时返回序列的第一个元素\",\"使用next()获得序列中的下一个元素。\",\"使用hasNext()检查序列中是否还有元素。\",\"使用remove()将迭代器新返回的元素删除。\"]},\"26\":{\"h\":\"HashMap底层实现\"},\"27\":{\"h\":\"jdk1.8之前\",\"t\":[\"JDK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列(数组中的每个元素都是一个链表)。HashMap 通过 key 的hashCode 经过扰动函数(HashMap的hash方法,减少冲突概率)处理过后得到 hash值，然后通过 (n - 1) & hash判断当前元素存放的位置（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同则利用链表在原结点后插入新的结点.\"]},\"28\":{\"h\":\"jdk1.8之前\",\"t\":[\"当链表的长度大于阈值(默认8)时,将链表转换为红黑树,减少搜索时间.\"]},\"29\":{\"h\":\"ConcurrentHashMap 和 Hashtable 实现线程安全的区别\",\"t\":[\"Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常 低下。\",\"在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶 数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数 据段的数据，就不会存在锁竞争，提⾼并发访问率。(⼀个 ConcurrentHashMap ⾥包含⼀个 Segment 数组。⼀个 Segment 包含⼀个 HashEntry 数组，每个 HashEntry 是⼀个链表结构的元素) \",\"JDK1.8 的时候已经摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和CAS来操作。synchronized只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要hash不冲突，就不会产⽣并发，效率⼜ 提升N倍。\",\")\",\"comparable接⼝出⾃java.lang包 它有⼀个 compareTo(Object obj) ⽅法⽤来排 序(在实体类中实现,String和包装类都默认实现了)\",\"comparator接⼝出⾃ java.util 包它有⼀个 compare(Object obj1, Object obj2) ⽅法⽤来排序(无法修改实体类时，直接在调用方通过匿名内部类的方式创建) \",\"TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比 较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。\",\"TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元 素进行排序。\",\"Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。\"]},\"30\":{\"h\":\"字符串String\"},\"31\":{\"h\":\"Stirng方法\",\"t\":[\"String 是不可变的,String 类中使⽤ final 关键字修饰字符数组来保存字符串\",\"使用 + 号拼接字符串,如果+号左右存在变量则调用的StringBuilder的 append() 方法拼接然后进行 toString() 相当于 new 一个字符串在堆. 若两边都是字面字符常量会在编译期就合并了.\"]},\"32\":{\"h\":\"常用方法\",\"t\":[\" String.valueof(xxx) //将xxx转换为string类型 length() //字符串长度 trim() //去字符串前后空格 split(n) //按n（为字符或正则）进行字符串切割 replaceall(正则，新符号) //替换可字符可正则 replace(被替换字符，新字符) //替换只能用字符 substring(begin，end) //获取子字符串，含头不含尾从0开始数 s1.compareTo(s2) //字符串比较，实际上就是做减法从第一个不相同的字符开始比 equals(str）//字符串内容是否相同 equalsIgnorecase(str) //忽略大小写比较内容 isEmpty() //判断字符串是否为空 concat() //字符串连接 startsWith() //方法用于检测字符串是否以指定的前缀开始。 startsWith(String prefix, int toffset) //字符串中开始查找的位置,查找前缀 startsWith(String prefix) endsWith(String suffix) //测试此字符串是否以指定的后缀结尾 format() //字符串格式化,只用%s就可以接受大部分数据 String.format(\\\"%s %s\\\",msg1,msg2); 比使用+或 concat()方法节省内存 toUpperCase() //转成大写字母 charAt(int index) //指定索引处的字符。索引范围为从 0 到 length() - 1。 indexOf(int ch) //返回指定字符在此字符串中第一次出现处的索引。 toCharArray() //字符串 转为 char [] //如果该对象代表的字符串在常量池可以找到，那么，返回该常量的引用，如果找不到，那么，去堆中查找，堆中存在，则讲堆中对象的引用放入常量池(注意是对象的引用)，并返回该引用，如果都没有找到，则讲该字面量放入常量池 intern() \"]},\"33\":{\"h\":\"StringBuffer StringBuilder方法\",\"t\":[\"StringBuffer和StringBuilder是可变的,没用final修饰字符数组 内部char数组长度为构建时初始字符串长度加 16；\",\"如果要操作少量的数据用 String,线程安全；\",\"多线程操作字符串缓冲区下操作大量数据 StringBuffer，使用了同步锁速度较慢线程安全；\",\"单线程操作字符串缓冲区下操作大量数据 StringBuilder；速度最快线程不安全\"]},\"34\":{\"h\":\"常用方法\",\"t\":[\" append() //追加字符串 reverse() //反转字符串 delete(int start, int end) //移除此序列的子字符串中的字符。 replace(int start, int end, String str) //使用给定 String 中的字符替换此序列的子字符串中的字符。 \"]},\"35\":{\"h\":\"String不可变的好处\",\"t\":[\"保证hash 值相同: 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变 的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\",\"String Pool 字符串常量池的需要: 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\",\"线程安全性: 不可变保证了字符串本身是线程安全的\",\" //String比较 //常量池中创建一个\\\"11\\\"对象 String str=\\\"11\\\"; //在堆中创建对象，并且新建一个\\\"11\\\"对象放入常量池 String s1=new String(\\\"11\\\"); //创建5个，分别是堆中的3个：\\\"11\\\" \\\"111\\\" \\\"11111\\\"，常量池2个 \\\"11\\\" \\\"111\\\" String s1=new String(\\\"11\\\")+new String(\\\"111\\\"); String s1 = \\\"Programming\\\"; String s2 = new String(\\\"Programming\\\"); String s3 = \\\"Program\\\"; String s4 = \\\"ming\\\"; String s5 = \\\"Program\\\" + \\\"ming\\\"; String s6 = s3 + s4; System.out.println(s1 == s2); // false System.out.println(s1 == s5); // true System.out.println(s1 == s6); // false System.out.println(s1 == s6.intern()); // true System.out.println(s2 == s2.intern()); // false \"]},\"36\":{\"h\":\"判断字符串是否为数字\"},\"37\":{\"h\":\"用JAVA自带的函数\",\"t\":[\" public static boolean isNumeric(String str) { for (int i = str.length(); --i >= 0;) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; } \"]},\"38\":{\"h\":\"使用lang3下的包下StringUtils类的方法isNumeric()\",\"t\":[\" String str=\\\"1235456\\\"; boolean flag =StringUtils.isNumeric(str); \"]},\"39\":{\"h\":\"用正则表达式\",\"t\":[\" public static boolean isNumeric(String str) { Pattern pattern = Pattern.compile(\\\"[0-9]*\\\"); return pattern.matcher(str).matches(); } \"]},\"40\":{\"h\":\"I/O流\"},\"41\":{\"h\":\"分类\",\"t\":[\"按照流的流向分，可以分为输⼊流和输出流；\",\"按照操作单元划分，可以划分为字节流和字符流；\",\"按照流的⻆⾊划分为节点流和处理流\"]},\"42\":{\"h\":\"基类\",\"t\":[\"InputStream/Reader: 所有的输⼊流的基类，前者是字节输⼊流，后者是字符输⼊流。\",\"OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\"]},\"43\":{\"h\":\"既然有了字节流,为什么还要有字符流?\",\"t\":[\"​ 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，但字节流处理多个字节表示的东西的时候有可能会出现乱码的问题，比如汉字，用字节流读取的时候有可能因为一位字节没有读到就变成了乱码。但字符流可以解决这样的问题：字节流和编码表的组合就是字符流。有了编码表可以确定这个汉字有多少个字节，这样字节流就可以根据位数准确的读写汉字了。\"]},\"44\":{\"h\":\"文件读取写入\",\"t\":[\" //字节流 public static void main(String[] args) throws IOException { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //原有的文件Test.txt bis = new BufferedInputStream(new FileInputStream(\\\"D:\\\\\\\\Test.txt\\\")); bos = new BufferedOutputStream(new FileOutputStream(\\\"D:\\\\\\\\newTest.txt\\\")); int len = 0; while ((len = bis.read()) != -1) { bos.write(len); } }catch (Exception e){ }finally { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } } \",\" //字符流 public static void main(String[] args) throws Exception { // 创建一个字符输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(\\\"D:\\\\\\\\Test.txt\\\")); // 创建一个字符输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"D:\\\\\\\\newTest.txt\\\")); // 声明一个字符串变量str String str = null; // 循环时每次读取一行文本，如果不为null（即到了文件末尾），则继续循环 while ((str = br.readLine()) != null) { // 将读取到的一行字符串写入到文件中 bw.write(str); // 写入一个换行符，方便下次写入 bw.newLine(); } // 关闭输入流 br.close(); // 关闭输出流 bw.close(); } \"]},\"45\":{\"h\":\"File类\"},\"46\":{\"h\":\"常用方法\",\"t\":[\" listFiles() //返回子文件和子目录的file数组 isFile() //判断是否为文件 exists() //判断file对象对应的文件或目录是否存在 delete() //删除 createNewFile() //文件不存在则创建指定文件 getName() //获取文件名 lastModified() //获取文件最后一次修改时间 mkdir() //创建指定目录 mkdirs() //创建指定目录,当父目录不存在时一起创建 \"]},\"47\":{\"h\":\"Java中的多线程和JUC\"},\"48\":{\"h\":\"线程创建\",\"t\":[\"java无法真正开启线程,只能通过private native void start0(); 调用本地方法.让本地c++方法开启线程,因为java运行在虚拟机上无法直接操作硬件.\"]},\"49\":{\"h\":\"继承Thread类\",\"t\":[\"继承Thread类，重写run方法，创建对象,调用start方法开启线程执行run方法.\",\" public class Test extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i < 10; i++) { System.out.println(\\\"--{\\\"+i+\\\"}--\\\"); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 Test test = new Test(); //调用start方法开启线程 test.start(); for (int i = 0; i < 10; i++) { System.out.println(\\\"【\\\"+i+\\\"】\\\"); } } } 输出： 【0】 【1】 --{0}-- --{1}-- --{2}-- --{3}-- --{4}-- --{5}-- --{6}-- --{7}-- --{8}-- --{9}-- 【2】 【3】 【4】 【5】 【6】 【7】 【8】 【9】 //！！！start()方法开启的子线程不一定立即执行,由CPU决定调度那个线程！！！ \"]},\"50\":{\"h\":\"实现Runnable接口\",\"t\":[\" public class TalkSend implements Runnable{ //xxx @Override public void run(){ // xxx } } public class TalkReceive implements Runnable{ //xxx @Override public void run(){ // xxx } } //开启两个线程 new Thread(new TalkSend(5555,\\\"localhost\\\",8888)).start; new Thread(new TalkReceive(9999,\\\"学生\\\")).start; //内部类 new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(3000); } catch (InterruptedException e1) { e1.printStackTrace(); } } }).start(); //真实开发中,类不用实现接口,直接new线程将对象传入线程要通过线程池获取 //资源类不需要实现Runnable接口,重写run方法. 完成解耦 class Ticket{ //正常编写属性和方法 private int num =50; public void sale(){ //..... } } public static void main(String[] args){ Ticket tk = new Ticket(); //使用lambda表达式,启动线程 new Thread(()-> {tk.sale();},\\\"线程A\\\").start(); new Thread(()-> {tk.sale();},\\\"线程B\\\").start(); new Thread(()-> {tk.sale();},\\\"线程C\\\").start(); } \"]},\"51\":{\"h\":\"实现Callable接口\",\"t\":[\"有返回值(和指定的泛型相同),可以抛出异常\",\"实现callable接口(要指定泛型),\",\"重写call方法.\",\"因为Thread不能直接 接收Callable接口,所有要通过FutureTask适配类 FutureTask即可接收Callable接口,也可接收Runnable接口\",\"FutureTask的 get 方法获取Callable接口call方法的返回值. 可能会因为call方法没执行完而阻塞\",\"public class TestThread implements Callable<Integer>{ @Override public Integer call() throws Exception { System.out.println(\\\"call()方法执行中...\\\"); return 1; } } public class Test extends Thread{ public static void main(String[] args) { TestThread testThread = new TestThread(); FutureTask futureTask = new FutureTask(testThread);//适配类 new Thread(futureTask,\\\"A\\\").start(); new Thread(futureTask,\\\"B\\\").start();//结果会被缓存，效率高 try { Integer o = (Integer) futureTask.get();//获取callable的返回结果 System.out.println(o); } catch (Exception e) { e.printStackTrace(); } } } 输出： call()方法执行中... 1 //注意: 开启了两个线程但因为结果会被缓存,所以call()方法只执行了一次. Executors.callable（Runnable task ）可以实现 Runnable 对象和 Callable 对象之间的 相互转换。 \"]},\"52\":{\"h\":\"Thread方法\",\"t\":[\" //构造器 new Thread(Runnable接口实现类对象); new Thread(Runnable接口实现类对象,线程名); //非静态方法 start(); //创建线程 setPriority(int) //更改线程优先级 getPriority() //获取线程优先级 a.join() //等待a线程运行结束后,再继续执行当前线程 isAlive() //检测线程是否处于活跃状态 interrupt() //中断线程,不推荐使用 //线程中断并不会使线程立即退出，而是给线程发送一个通知，告知线程需要退出了。至 于目标线程接到通知后如何处理是由它自己决定 getName() //获取线程名 //静态方法 Thread.currentThread() //获取当前的线程 Thread.sleep(200) //线程休眠200毫秒,不会释放锁 Thread.yield() //线程让出CPU,再共同竞争 \"]},\"53\":{\"h\":\"线程状态(Thread.State)\",\"t\":[\"jvm将操作系统中的running运行中和ready就绪隐藏起来,并且统一暴露为runnable可运行的.因为jvm无法进行cpu的调度.\",\"阻塞和等待的区别在于，阻塞是被动的，而等待是主动的，不会被分配 CPU 执行时间, 需要显式被唤\"]},\"54\":{\"h\":\"线程优先级priority\",\"t\":[\"优先级用数字表示1-10,数字越大优先级越高,main方法默认为5 注意: 先设置优先级再启动\"]},\"55\":{\"h\":\"守护线程daemon\",\"t\":[\"虚拟机不需要等待守护线程执行完毕\",\"虚拟机必须等待用户线程执行完毕\",\"Thread thread=new Thread(god);\",\"thread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程.\"]},\"56\":{\"h\":\"停止线程\",\"t\":[\"不推荐使用jdk提供的停止线程方法: stop destroy\",\"推荐让线程自己停下来\",\"使用一个标志位来停止线程,并对外提供一个修改标识的方法\"]},\"57\":{\"h\":\"ThreadLocal 数据隔离\",\"t\":[\"通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。\",\"每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局 部变量进行冲突，实现了线程的数据隔离。\",\" ThreadLocal<String> mStringThreadLocal = new ThreadLocal<>(); mStringThreadLocal.set(\\\"droidyue.com\\\"); mStringThreadLocal.get(); mStringThreadLocal.remove(); //ThreadLocal必须在使用完成后手动回收 private static final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){ @Override // 设置默认get()方法初始化值 protected SimpleDateFormat initialValue(){ return new SimpleDateFormat(\\\"yyyyMMdd HHmm\\\"); } }; \"]},\"58\":{\"h\":\"ThreadLocal 适用于如下两种场景\",\"t\":[\"每个线程需要有自己单独的实例\",\"实例需要在多个方法中共享，但不希望被多线程共享\"]},\"59\":{\"h\":\"ThreadLocal 原理\",\"t\":[\"ThreadLocal 内部维护的是㇐个类似 Map 的 ThreadLocalMap 数据结构， key 为当前对象的ThreadLocal 对象，值为 set的值.\",\"每个线程都有自己ThreadLocalMap 对象,线程将ThreadLocal作为key从 ThreadLocalMap获取属于自己的value。\"]},\"60\":{\"h\":\"ThreadLocal 内存泄露问题\",\"t\":[\"ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。 如果一个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一 来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。假如我们不做任何措施的 话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。当调用 set(),get(),remove()时都会清空key为null的记录\"]},\"61\":{\"h\":\"线程复用问题\",\"t\":[\"使用线程池或直接复用线程时,由于线程会进行复用导致第二次使用ThreadLocal时 还遗留了第一个线程设置的值.\",\"处理办法：\",\"ThreadLocal使用完后使用remove()进行回收\",\"线程执行前将ThreadLocal set为null\",\"重写ThreadPoolExecutor的afterExecute(或beforeExecute)以清除 ThreadLocal\"]},\"62\":{\"h\":\"线程同步\"},\"63\":{\"h\":\"synchronized 同步锁,可重入锁，悲观锁\"},\"64\":{\"h\":\"实现原理\"},\"65\":{\"h\":\"修饰代码块：jvm会在字节码文件中在同步代码块开始位置插入 monitorenter(进入监控)在同步代码块结束位置插入monitorexit(退出监控)指 令.当执⾏monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor 对象存在于每个Java对象的对象头中)当计数器为0则可以成功获取，获取后将锁 计数器加1。相应的在执⾏monitorexit 指令后，将锁计数器减一，当计数器为0 时表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另 外㇐个线程释放为⽌。\"},\"66\":{\"h\":\"修饰方法： jvm会在字节码文件中方法标识符中添加一个 acc_synchronized标识.执行线程需要先获得monitor锁，然后开始执行方法，方 法执行之后再释放monitor锁，当方法不管是正常return还是抛出异常都会释放 对应的monitor锁。\"},\"67\":{\"h\":\"锁的范围\",\"t\":[\"非静态方法: 每个对象都有一个monitor锁(对象锁),记录在对象头的Mark Word中.\",\"静态方法: 静态方法在类加载时就生成了,存在于.class字节码文件中,不管 new 多少个对象都只有一个锁 (类锁,只锁静态方法,与对象锁互不干扰).\"]},\"68\":{\"h\":\"使用方式\",\"t\":[\"同步方法: 在方法的访问权限修饰符后,使用synchronized修饰\",\"同步代码块: synchronized (obj) { } //obj为同步监视器,可以是任何对象,但推荐使用共享资源.同步方法中无需指定 同步监视器,因为同步方法的同步监视器就是this即对象本身.\",\"注意:当使用String作为监视器时,如果两个字符串相同且后一个不是new 出来 的,那么这两个字符串从同一个地址取值,可以看做同一个对象.锁也是共用的,可能导致死锁等问题.\"]},\"69\":{\"h\":\"synchronized 优化\",\"t\":[\"JVM在JDK 1.6中引入了分级锁机制来优化synchronized(1.6之前一直是重量级锁,挂起或唤醒线程需要操作系统从用户态转为内核态即为耗时)\",\"当一个线程获取锁时，首先对象锁成为一个偏向锁,如果在接下来的执行 中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步 操作！(这是为了避免在同一线程重复获取同一把锁时，用户态和内核态频繁切换)\",\"如果有多个线程竞争锁资源，锁将会升级为轻量级锁(CAS):\",\"这适用于在短时间内持有锁，且分锁交替切换的场景\",\"轻量级锁还结合了自旋锁来避免线程用户态与内核态的频繁切换\",\"如果锁竞争太激烈（自旋锁失败），同步锁会升级为重量级锁\",\"优化synchronized同步锁的关键：减少锁竞争: \",\"应该尽量使synchronized同步锁处于轻量级锁或偏向锁， 这样才能提高synchronized同步锁的性能\",\"常用手段: \",\"减少锁粒度：降低锁竞争\",\"减少锁的持有时间，提高synchronized同 步锁在自旋时获取锁资源的成功率，避免升级为 重量级锁\",\"锁消除: 虚拟机即使编译器在运行时，如 果检测到那些共享数据不可能存在竞争，那 么就执行锁消除。锁消除可以节省毫无意义 的请求锁的时间。\",\"锁粗化: 原则上，我们在编写代码的时 候，总是推荐将同步块的作用范围限制得尽 量小,但是如果一系列的连续操作都对同一个 对象反复加锁和解锁，那么会带来很多不必 要的性能消耗.\",\"在锁竞争激烈时，可以考虑禁用偏向锁和禁用自旋锁\"]},\"70\":{\"h\":\"LOCK\",\"t\":[\"lock接口的实现类\"]},\"71\":{\"h\":\"注解 Annotation\"},\"72\":{\"h\":\"JDK内置注解\",\"t\":[\"@Override //修饰方法,表示为重写 @Deprecated //修饰方法，属性，类,表示废弃 @FunctionalInterface //函数式接口 @SuppressWarnings(\\\"范围\\\") //压制警告 \"]},\"73\":{\"h\":\"元(meta)注解\",\"t\":[\"解释注解的注解\",\"@Target(value={ElementType.xxx}) //用于描述注解的使用范围:TYPE类,FIELD字段 @Retention(value=RetentionPolicy.xxx) //表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE<CLASS< RUNTIME） @Document //说明该注解将被包含在javadoc中 @lnherited //说明子类可以继承父类中的该注解 \"]},\"74\":{\"h\":\"自定义注解\",\"t\":[\"@interface用来声明一个注解，格式：public @interface 注解名\",\"其中的每一个方法实际上是声明了一个配置参数.\",\"方法的名称就是参数的名称.\",\"返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum,注解,以上类型的数组）.\",\"可以通过default来声明参数的默认值\",\"如果只有一个参数成员，一般参数名为value,并且使用时value可不写\",\"注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值.\",\"public @interface MyAnnotation{ //参数类型 参数名 (); String name() default \\\"默认值\\\"; String[] schools(); } @Aspect 配合 @Pointcut(\\\"@annotation(com.demo.MyAnnotation)\\\") //表示匹配路径为com.demo.MyAnnotation的注解执行AOP业务 \",\"反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。\"]},\"75\":{\"h\":\"获取Class对象\",\"t\":[\"Class.forName(\\\"全类名\\\"); 类名.class; 对象.getClass(); 包装类.TYPE; \",\"同一个字节码文件(.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。\"]},\"76\":{\"h\":\"Class类的方法\",\"t\":[\"static Class forName（String name）//返回指定类名name的Class对象 Object newInstance（）//调用无参构造函数，返回Class对象的一个实例 getName（）//返回此Class对象所表示的实体（类，接口，数组类或void）的全类名。 getSimpleName() //获取简单的类名 Class getSuperClass（）//返回当前Class对象的父类的Class对象 // 如果此 Class 表示Object 类、一个接口、一个基本类型或 void，则返回 null getinterfaces（）//获取当前Class对象的接口 ClassLoader getClassLoader（）//返回该类的类加载器 Constructor[] getConstructors（）//获取该类所有的public的构造函数 Method getMothed（String name，Class..T）//返回只能方法名和参数类型的方法 getMotheds() //获取本类和父类的所有public方法 getDeclaredMotheds() //获取本类的所有方法 Field[] getFields() //返回public的属性 Field[] getDeclaredFields（）//返回所有属性 invoke(Object 对象,Object.. 参数); //执行方法 setAccessible(true); //允许操作private的字段,方法 \",\"//根据指定构造器创建对象 constructor=clazz.getDeclaredConstructor(Class..); constructor.newInstance(方法参数..); //通过反射执行指定对象的指定方法 mothed=clazz.getDeclaredMothed(name,Class..T); mothed.setAccessible(true); //允许操作private方法 mothed.invoke(对象,方法参数值..); //通过反射操作指定对象的指定字段 field=clazz.getDeclaredField(name,Class..T); field.setAccessible(true); //允许操作private字段 field.set(对象,字段值); \"]},\"77\":{\"h\":\"获取方法泛型信息\",\"t\":[\"//获取方法参数类型 Type[] genericParameterTypes=mothed.getGenericParameterTypes(); for(Type genericParameterTtpe : genericParameterTypes){ //如果参数类型是泛型 if(genericParameterTtpe instanceof ParameterizedType){ //获取泛型 Type[] actualTpyeArguments = genericParameterTtpe.getActualTpyeArguments() } } //获取方法返回值类型 Type genericReturnType= mothed.getGenericReturnType(); \"]},\"78\":{\"h\":\"获取注解信息\",\"t\":[\"Annotation[] annotations= clazz.getAnnotations(); //获取全部的注解 annotation=field.getAnnotation(注解名.class);//获取字段上指定注解 annotation=clazz.getAnnotation(注解名.class);//获取类上指定注解 annotation.注解属性(); //获取注解属性的值 \"]},\"79\":{\"h\":\"正则表达式\",\"t\":[\". 匹配除换行符以外的任意字符 [] 匹配所包含的任意一个字符。 [aeiou] 匹配aeiou任意一个 [0-9]、[a-z] 范围匹配 ^ 在 [ ] 中是取非操作 在 [ ] 中 . 不是元字符 + 匹配 1 个或者多个字符 * 匹配 0 个或者多个字符 ? 匹配 0 个或者 1 个字符 {n} 匹配 n 个字符 {m,n} 匹配 m~n 个字符 {m,} 至少匹配 m 个字符 # 分组 () 子表达式,子表达式的内容可以当成一个独立元素表示一个分组，即可以将它看成一个字符，并且使用 * 等元字符。 (\\\\w)(\\\\w) 自动命名分组，第一个小括号是分组1，第二个小括号是分组2 (?'Word'\\\\w+)) 表示定义了一个叫做Word的分组 (?<Word>\\\\w+)) 表示定义了一个叫做Word的分组 (?:\\\\w+) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 # 后向引用 \\\\1 表示分组1匹配的文本 \\\\k<Word> 表示分组Word匹配的文本 \\\\ 转义字符, /需要进行转义才能匹配到 | 指明两项之间的一个选择。 \\\\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 \\\\G 上一个匹配的结尾（本次匹配开始） \\\\A 字符串开头(类似^，但不受处理多行选项的影响) \\\\Z 字符串结尾或行尾(不受处理多行选项的影响) \\\\z 字符串结尾(类似$，但不受处理多行选项的影响) \\\\f 换页符 \\\\n 换行符 \\\\r 回车符 \\\\t 制表符 \\\\v 垂直制表符 \\\\d 数字字符，等价于 [0-9] \\\\D 非数字字符，等价于 [^0-9] \\\\w 大小写字母，下划线和数字，等价于 [a-zA-Z0-9_] \\\\W 对 \\\\w 取非 \\\\s 任何一个空白字符，等价于 [\\\\f\\\\n\\\\r\\\\t\\\\v] \\\\S 对 \\\\s 取非 # 零宽断言（正向和负向）:匹配字符的时候再添加一些定位条件，使匹配更精准。 \\\\w+(?=ing) 匹配以ing结尾的多个字符（不包括ing） \\\\w+(?!ing) 匹配不是以ing结尾的多个字符 (?<=re)\\\\w+ 匹配以re开头的多个字符（不包括re） (?<!re)\\\\w+ 匹配不是以re开头的多个字符 (?<=\\\\s)\\\\d+(?=\\\\s) 匹配两边是空白符的数字，不包括空白符 # 懒惰(匹配尽可能短的字符串)模式的启用只需在重复元字符之后加?既可。 # 正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 # 在表达式里插记号的方式来启用绝大多数的模式，在正则的哪里插入，就从哪里启用。 (?i)：忽略大小写(CASE_INSENSITIVE) (?x)：忽略空格字符(COMMENTS) (?s)：.匹配任意字符，包括换行符（DOTALL） (?m)：多行模式（MULTILINE） (?u)：对Unicode符大小写不敏感（UNICODE_CASE），必须启用CASE_INSENSITIVE (?d)：只有'\\\\n'才被认作一行的中止（UNIX_LINES） # 平衡组/递归匹配:用于匹配嵌套层次结构，常用于匹配HTML标签（当HTML内容不规范，起始标签和结束标签数量不同时，匹配出正确配对的标签） (?'group'\\\\w) 捕获的分组（\\\\w匹配到的内容）命名为group，并压入堆栈 (?'-group'\\\\w) 捕获分组（\\\\w匹配到的内容）后，弹出group分组栈的栈顶内容（最后压入的捕获内容），堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) 如果group栈非空匹配表达式yes，否则匹配表达式no (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败 # 注释 (?#comment) \",\"标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。\",\"标记不写在正则表达式里，标记位于表达式之外，格式如下：/pattern/flags\",\"修饰符\",\"含义\",\"描述\",\"i\",\"ignore - 不区分大小写\",\"将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。\",\"g\",\"global - 全局匹配\",\"查找所有的匹配项。\",\"m\",\"more - 多行匹配\",\"使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。\",\"s\",\"特殊字符圆点 . 中包含换行符 \\\\n\",\"默认情况下的圆点 . 是 匹配除换行符 \\\\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\\\n。\",\"java正则表达式中 \\\"\\\\\\\\\\\" 代表一个正则\\\"\\\\\\\",所以正则中\\\"\\\\\\\\\\\\\\\\\\\"代表一个真正的\\\"\\\\\\\" \",\"Pattern p = Pattern.compile(\\\".*\\\\\\\\d+.*\\\"); //创建指定规则的正则对象 Matcher m = p.matcher(content); //获取matcher对象 boolean b = m.matches() //判断字符串是否匹配规则 \"]},\"80\":{\"h\":\"Java S E\"},\"81\":{\"h\":\"Java\"}},\"dirtCount\":0,\"index\":[[\"代表一个真正的\",{\"1\":{\"79\":1}}],[\"代表一个正则\",{\"1\":{\"79\":1}}],[\"代码段会产生额外的性能开销\",{\"1\":{\"3\":1}}],[\"特殊字符圆点\",{\"1\":{\"79\":1}}],[\"记住是多行\",{\"1\":{\"79\":1}}],[\"记录在对象头的mark\",{\"1\":{\"67\":1}}],[\"查找所有的匹配项\",{\"1\":{\"79\":1}}],[\"查找前缀\",{\"1\":{\"32\":1}}],[\"全局匹配\",{\"1\":{\"79\":1}}],[\"全类名\",{\"1\":{\"75\":1}}],[\"搜索时不区分大小写\",{\"1\":{\"79\":1}}],[\"描述\",{\"1\":{\"79\":1}}],[\"含义\",{\"1\":{\"79\":1}}],[\"含头不含尾从0开始数\",{\"1\":{\"32\":1}}],[\"含头不含尾\",{\"1\":{\"5\":1}}],[\"标记位于表达式之外\",{\"1\":{\"79\":1}}],[\"标记不写在正则表达式里\",{\"1\":{\"79\":1}}],[\"标记也称为修饰符\",{\"1\":{\"79\":1}}],[\"试图匹配总是失败\",{\"1\":{\"79\":1}}],[\"零宽负向先行断言\",{\"1\":{\"79\":1}}],[\"零宽断言\",{\"1\":{\"79\":1}}],[\"否则匹配表达式no\",{\"1\":{\"79\":1}}],[\"堆栈本来为空\",{\"1\":{\"79\":1}}],[\"堆中存在\",{\"1\":{\"32\":1}}],[\"弹出group分组栈的栈顶内容\",{\"1\":{\"79\":1}}],[\"命名为group\",{\"1\":{\"79\":1}}],[\"捕获分组\",{\"1\":{\"79\":1}}],[\"捕获的分组\",{\"1\":{\"79\":1}}],[\"捕获异常后不要不做任何操作或直接e\",{\"1\":{\"3\":1}}],[\"起始标签和结束标签数量不同时\",{\"1\":{\"79\":1}}],[\"递归匹配\",{\"1\":{\"79\":1}}],[\"平衡组\",{\"1\":{\"79\":1}}],[\"才被认作一行的中止\",{\"1\":{\"79\":1}}],[\"才可能使用\",{\"1\":{\"35\":1}}],[\"忽略空格字符\",{\"1\":{\"79\":1}}],[\"忽略大小写\",{\"1\":{\"79\":1}}],[\"忽略大小写比较内容\",{\"1\":{\"32\":1}}],[\"最后压入的捕获内容\",{\"1\":{\"79\":1}}],[\"最先开始的匹配拥有最高的优先权\",{\"1\":{\"79\":1}}],[\"最简便的方法\",{\"1\":{\"20\":1}}],[\"贪婪规则的优先级更高\",{\"1\":{\"79\":1}}],[\"既可\",{\"1\":{\"79\":1}}],[\"既然有了字节流\",{\"0\":{\"43\":1}}],[\"模式的启用只需在重复元字符之后加\",{\"1\":{\"79\":1}}],[\"懒惰\",{\"1\":{\"79\":1}}],[\"任何一个空白字符\",{\"1\":{\"79\":1}}],[\"取非\",{\"1\":{\"79\":2}}],[\"下划线和数字\",{\"1\":{\"79\":1}}],[\"下标越界异常\",{\"1\":{\"3\":1}}],[\"垂直制表符\",{\"1\":{\"79\":1}}],[\"制表符\",{\"1\":{\"79\":1}}],[\"回车符\",{\"1\":{\"79\":1}}],[\"回收\",{\"1\":{\"60\":1}}],[\"换行符\",{\"1\":{\"79\":1}}],[\"换页符\",{\"1\":{\"79\":1}}],[\"本次匹配开始\",{\"1\":{\"79\":1}}],[\"本地时间\",{\"0\":{\"16\":1}}],[\"上一个匹配的结尾\",{\"1\":{\"79\":1}}],[\"上面的枚举类\",{\"1\":{\"4\":1}}],[\"$\",{\"1\":{\"79\":2}}],[\"后\",{\"1\":{\"79\":1}}],[\"后向引用\",{\"1\":{\"79\":1}}],[\"后者是字符输出流\",{\"1\":{\"42\":1}}],[\"后者是字符输⼊流\",{\"1\":{\"42\":1}}],[\"子表达式的内容可以当成一个独立元素表示一个分组\",{\"1\":{\"79\":1}}],[\"子表达式\",{\"1\":{\"79\":1}}],[\"个字符\",{\"1\":{\"79\":4}}],[\"个或者\",{\"1\":{\"79\":1}}],[\"个或者多个字符\",{\"1\":{\"79\":2}}],[\"z0\",{\"1\":{\"79\":1}}],[\"za\",{\"1\":{\"79\":1}}],[\"z\",{\"1\":{\"79\":3}}],[\"匹配除换行符\",{\"1\":{\"79\":1}}],[\"匹配除换行符以外的任意字符\",{\"1\":{\"79\":1}}],[\"匹配每一行的开头和结尾\",{\"1\":{\"79\":1}}],[\"匹配出正确配对的标签\",{\"1\":{\"79\":1}}],[\"匹配任意字符\",{\"1\":{\"79\":1}}],[\"匹配尽可能短的字符串\",{\"1\":{\"79\":1}}],[\"匹配两边是空白符的数字\",{\"1\":{\"79\":1}}],[\"匹配不是以re开头的多个字符\",{\"1\":{\"79\":1}}],[\"匹配不是以ing结尾的多个字符\",{\"1\":{\"79\":1}}],[\"匹配以re开头的多个字符\",{\"1\":{\"79\":1}}],[\"匹配以ing结尾的多个字符\",{\"1\":{\"79\":1}}],[\"匹配字符的时候再添加一些定位条件\",{\"1\":{\"79\":1}}],[\"匹配字符串的结束\",{\"1\":{\"79\":1}}],[\"匹配字符串的开始\",{\"1\":{\"79\":1}}],[\"匹配单词的开始或结束\",{\"1\":{\"79\":1}}],[\"匹配exp\",{\"1\":{\"79\":1}}],[\"匹配\",{\"1\":{\"79\":5}}],[\"匹配aeiou任意一个\",{\"1\":{\"79\":1}}],[\"匹配所包含的任意一个字符\",{\"1\":{\"79\":1}}],[\"根据指定构造器创建对象\",{\"1\":{\"76\":1}}],[\"根据毫秒值或者date转换为instant\",{\"1\":{\"15\":1}}],[\"允许操作private字段\",{\"1\":{\"76\":1}}],[\"允许操作private方法\",{\"1\":{\"76\":1}}],[\"允许操作private的字段\",{\"1\":{\"76\":1}}],[\"允许重复\",{\"1\":{\"18\":1}}],[\"甚至可以运行时修改类定义\",{\"1\":{\"74\":1}}],[\"官方用语\",{\"1\":{\"74\":1}}],[\"赋予程序在运行时自省\",{\"1\":{\"74\":1}}],[\"语言提供的一种基础功能\",{\"1\":{\"74\":1}}],[\"配合\",{\"1\":{\"74\":1}}],[\"经常使用空字符串\",{\"1\":{\"74\":1}}],[\"经过扰动函数\",{\"1\":{\"27\":1}}],[\"一个基本类型或\",{\"1\":{\"76\":1}}],[\"一个接口\",{\"1\":{\"76\":1}}],[\"一个字符串在堆\",{\"1\":{\"31\":1}}],[\"一般参数名为value\",{\"1\":{\"74\":1}}],[\"格式如下\",{\"1\":{\"79\":1}}],[\"格式\",{\"1\":{\"74\":1}}],[\"格式化\",{\"0\":{\"12\":1},\"1\":{\"17\":1}}],[\"说明子类可以继承父类中的该注解\",{\"1\":{\"73\":1}}],[\"说明该注解将被包含在javadoc中\",{\"1\":{\"73\":1}}],[\"解释注解的注解\",{\"1\":{\"73\":1}}],[\"解析\",{\"1\":{\"17\":1}}],[\"元\",{\"0\":{\"73\":1}}],[\"元素请使用\",{\"1\":{\"18\":1}}],[\"压制警告\",{\"1\":{\"72\":1}}],[\"范围匹配\",{\"1\":{\"79\":1}}],[\"范围\",{\"1\":{\"72\":1}}],[\"范围升序\",{\"1\":{\"5\":1}}],[\"函数式接口\",{\"1\":{\"72\":1}}],[\"属性\",{\"1\":{\"72\":1}}],[\"注释\",{\"1\":{\"79\":1}}],[\"注解属性\",{\"1\":{\"78\":1}}],[\"注解元素必须要有值\",{\"1\":{\"74\":1}}],[\"注解名\",{\"1\":{\"74\":1,\"78\":2}}],[\"注解\",{\"0\":{\"71\":1,\"73\":1},\"1\":{\"74\":1}}],[\"注意\",{\"1\":{\"51\":1,\"54\":1,\"68\":1}}],[\"注意是对象的引用\",{\"1\":{\"32\":1}}],[\"量小\",{\"1\":{\"69\":1}}],[\"总是推荐将同步块的作用范围限制得尽\",{\"1\":{\"69\":1}}],[\"候\",{\"1\":{\"69\":1}}],[\"么就执行锁消除\",{\"1\":{\"69\":1}}],[\"果检测到那些共享数据不可能存在竞争\",{\"1\":{\"69\":1}}],[\"避免升级为\",{\"1\":{\"69\":1}}],[\"步锁在自旋时获取锁资源的成功率\",{\"1\":{\"69\":1}}],[\"降低锁竞争\",{\"1\":{\"69\":1}}],[\"应该尽量使synchronized同步锁处于轻量级锁或偏向锁\",{\"1\":{\"69\":1}}],[\"自动命名分组\",{\"1\":{\"79\":1}}],[\"自旋锁失败\",{\"1\":{\"69\":1}}],[\"自定义注解\",{\"0\":{\"74\":1}}],[\"自定义格式\",{\"1\":{\"17\":1}}],[\"自定义异常的考虑\",{\"1\":{\"3\":1}}],[\"自定义检查异常\",{\"1\":{\"3\":1}}],[\"自定义非检查异常\",{\"1\":{\"3\":1}}],[\"轻量级锁还结合了自旋锁来避免线程用户态与内核态的频繁切换\",{\"1\":{\"69\":1}}],[\"该锁没有被其他线程获取\",{\"1\":{\"69\":1}}],[\"该接口提供了比\",{\"1\":{\"29\":1}}],[\"首先对象锁成为一个偏向锁\",{\"1\":{\"69\":1}}],[\"挂起或唤醒线程需要操作系统从用户态转为内核态即为耗时\",{\"1\":{\"69\":1}}],[\"优化synchronized同步锁的关键\",{\"1\":{\"69\":1}}],[\"优化\",{\"0\":{\"69\":1}}],[\"优先级用数字表示1\",{\"1\":{\"54\":1}}],[\"锁粗化\",{\"1\":{\"69\":1}}],[\"锁消除可以节省毫无意义\",{\"1\":{\"69\":1}}],[\"锁消除\",{\"1\":{\"69\":1}}],[\"锁将会升级为轻量级锁\",{\"1\":{\"69\":1}}],[\"锁也是共用的\",{\"1\":{\"68\":1}}],[\"锁的范围\",{\"0\":{\"67\":1}}],[\"出来\",{\"1\":{\"68\":1}}],[\"与对象锁互不干扰\",{\"1\":{\"67\":1}}],[\"与上面相反\",{\"1\":{\"15\":1}}],[\"多行匹配\",{\"1\":{\"79\":1}}],[\"多行模式\",{\"1\":{\"79\":1}}],[\"多少个对象都只有一个锁\",{\"1\":{\"67\":1}}],[\"多线程操作字符串缓冲区下操作大量数据\",{\"1\":{\"33\":1}}],[\"多线程访问容器⾥不同数\",{\"1\":{\"29\":1}}],[\"法执行之后再释放monitor锁\",{\"0\":{\"66\":1}}],[\"法将initialcapacity扩充为2的幂次⽅⼤⼩\",{\"1\":{\"21\":1}}],[\"然后开始执行方法\",{\"0\":{\"66\":1}}],[\"然后通过\",{\"1\":{\"27\":1}}],[\"外㇐个线程释放为⽌\",{\"0\":{\"65\":1}}],[\"直到锁被另\",{\"0\":{\"65\":1}}],[\"直接new线程将对象传入线程要通过线程池获取\",{\"1\":{\"50\":1}}],[\"直接在调用方通过匿名内部类的方式创建\",{\"1\":{\"29\":1}}],[\"直接覆盖\",{\"1\":{\"27\":1}}],[\"直接使用\",{\"1\":{\"18\":1}}],[\"那\",{\"1\":{\"69\":1}}],[\"那当前线程就要阻塞等待\",{\"0\":{\"65\":1}}],[\"那么会带来很多不必\",{\"1\":{\"69\":1}}],[\"那么持有偏向锁的线程就不需要进行同步\",{\"1\":{\"69\":1}}],[\"那么这两个字符串从同一个地址取值\",{\"1\":{\"68\":1}}],[\"那么在下一次垃圾回收的时候必然会被清理掉\",{\"1\":{\"60\":1}}],[\"那么就会从\",{\"1\":{\"35\":1}}],[\"那么\",{\"1\":{\"32\":2}}],[\"那么指定默\",{\"1\":{\"21\":1}}],[\"那么使用的mysql\",{\"1\":{\"16\":1}}],[\"计数器加1\",{\"0\":{\"65\":1}}],[\"计算差多少秒\",{\"1\":{\"12\":1}}],[\"计算差多少分钟\",{\"1\":{\"12\":1}}],[\"计算差多少小时\",{\"1\":{\"12\":1}}],[\"计算差多少天\",{\"1\":{\"12\":1}}],[\"计算日期间隔\",{\"1\":{\"12\":1}}],[\"令\",{\"0\":{\"65\":1}}],[\"退出监控\",{\"0\":{\"65\":1}}],[\"进入监控\",{\"0\":{\"65\":1}}],[\"进行回收\",{\"1\":{\"61\":1}}],[\"进行字符串切割\",{\"1\":{\"32\":1}}],[\"进行操作\",{\"1\":{\"12\":1}}],[\"进行date类日期的加\",{\"1\":{\"12\":1}}],[\"悲观锁\",{\"0\":{\"63\":1}}],[\"或beforeexecute\",{\"1\":{\"61\":1}}],[\"还遗留了第一个线程设置的值\",{\"1\":{\"61\":1}}],[\"由于没有后缀表达式\",{\"1\":{\"79\":1}}],[\"由于线程会进行复用导致第二次使用threadlocal时\",{\"1\":{\"61\":1}}],[\"由cpu决定调度那个线程\",{\"1\":{\"49\":1}}],[\"永远⽆法被gc\",{\"1\":{\"60\":1}}],[\"话\",{\"1\":{\"60\":1}}],[\"假如我们不做任何措施的\",{\"1\":{\"60\":1}}],[\"没有区别\",{\"1\":{\"79\":1}}],[\"没有被外部强引用的情况下\",{\"1\":{\"60\":1}}],[\"没用final修饰字符数组\",{\"1\":{\"33\":1}}],[\"⽽\",{\"1\":{\"60\":1}}],[\"⽽是直接⽤\",{\"1\":{\"29\":1}}],[\"原则上\",{\"1\":{\"69\":1}}],[\"原理\",{\"0\":{\"59\":1}}],[\"原有的文件test\",{\"1\":{\"44\":1}}],[\"适用于如下两种场景\",{\"0\":{\"58\":1}}],[\"适配类\",{\"1\":{\"51\":1}}],[\"设置默认get\",{\"1\":{\"57\":1}}],[\"部变量进行冲突\",{\"1\":{\"57\":1}}],[\"来\",{\"1\":{\"60\":1}}],[\"来对这个局部变量进行操作\",{\"1\":{\"57\":1}}],[\"来保证线程安全\",{\"1\":{\"29\":1}}],[\"来保存元素\",{\"1\":{\"18\":1}}],[\"推荐让线程自己停下来\",{\"1\":{\"56\":1}}],[\"停止线程\",{\"0\":{\"56\":1}}],[\"虚拟机即使编译器在运行时\",{\"1\":{\"69\":1}}],[\"虚拟机必须等待用户线程执行完毕\",{\"1\":{\"55\":1}}],[\"虚拟机不需要等待守护线程执行完毕\",{\"1\":{\"55\":1}}],[\"守护线程daemon\",{\"0\":{\"55\":1}}],[\"先设置优先级再启动\",{\"1\":{\"54\":1}}],[\"先执行对象的hashcode\",{\"1\":{\"21\":1}}],[\"数字字符\",{\"1\":{\"79\":1}}],[\"数字越大优先级越高\",{\"1\":{\"54\":1}}],[\"数据结构\",{\"1\":{\"59\":1}}],[\"数据隔离\",{\"0\":{\"57\":1}}],[\"数组类或void\",{\"1\":{\"76\":1}}],[\"数组+链表+红⿊树的数据结构来实现\",{\"1\":{\"29\":1}}],[\"数组+链表组成的\",{\"1\":{\"18\":1}}],[\"数组进⾏了分割分段\",{\"1\":{\"29\":1}}],[\"数组中的每个元素都是一个链表\",{\"1\":{\"27\":1}}],[\"数组和链表\",{\"1\":{\"27\":1}}],[\"数组大小\",{\"1\":{\"18\":1}}],[\"数组创建完成之后\",{\"1\":{\"18\":1}}],[\"数组创建后\",{\"1\":{\"5\":1}}],[\"数组必须是包装类型\",{\"1\":{\"5\":1}}],[\"数组转list\",{\"1\":{\"5\":1}}],[\"数组\",{\"0\":{\"5\":1},\"1\":{\"29\":2}}],[\"执行方法\",{\"1\":{\"76\":1}}],[\"执行线程需要先获得monitor锁\",{\"0\":{\"66\":1}}],[\"执行时间\",{\"1\":{\"53\":1}}],[\"执行输出结果\",{\"1\":{\"4\":1}}],[\"阻塞是被动的\",{\"1\":{\"53\":1}}],[\"阻塞和等待的区别在于\",{\"1\":{\"53\":1}}],[\"再共同竞争\",{\"1\":{\"52\":1}}],[\"再继续执行当前线程\",{\"1\":{\"52\":1}}],[\"yes|no\",{\"1\":{\"79\":1}}],[\"year\",{\"1\":{\"9\":1,\"11\":1}}],[\"yyyymmdd\",{\"1\":{\"57\":1}}],[\"yield\",{\"1\":{\"52\":1}}],[\"静态方法在类加载时就生成了\",{\"1\":{\"67\":1}}],[\"静态方法\",{\"1\":{\"52\":1,\"67\":1}}],[\"静态初始化\",{\"1\":{\"5\":1}}],[\"于目标线程接到通知后如何处理是由它自己决定\",{\"1\":{\"52\":1}}],[\"至少匹配\",{\"1\":{\"79\":1}}],[\"至\",{\"1\":{\"52\":1}}],[\"告知线程需要退出了\",{\"1\":{\"52\":1}}],[\"检测线程是否处于活跃状态\",{\"1\":{\"52\":1}}],[\"检查序列中是否还有元素\",{\"1\":{\"25\":1}}],[\"检查异常\",{\"1\":{\"3\":1}}],[\"更改线程优先级\",{\"1\":{\"52\":1}}],[\"更好处理异常\",{\"1\":{\"3\":1}}],[\"构造器\",{\"1\":{\"52\":1}}],[\"构造函数\",{\"1\":{\"4\":1}}],[\"构造函数只能使用\",{\"1\":{\"4\":1}}],[\"开启了两个线程但因为结果会被缓存\",{\"1\":{\"51\":1}}],[\"开启两个线程\",{\"1\":{\"50\":1}}],[\"结果会被缓存\",{\"1\":{\"51\":1}}],[\"结合在⼀起使⽤也就是\",{\"1\":{\"27\":1}}],[\"接收callable接口\",{\"1\":{\"51\":1}}],[\"接口的子类型\",{\"1\":{\"29\":1}}],[\"接口以实现元素的比较\",{\"1\":{\"29\":1}}],[\"接口从而根据键对元\",{\"1\":{\"29\":1}}],[\"接口\",{\"1\":{\"29\":1,\"76\":1}}],[\"启动线程\",{\"1\":{\"50\":1}}],[\"完成解耦\",{\"1\":{\"50\":1}}],[\"资源类不需要实现runnable接口\",{\"1\":{\"50\":1}}],[\"真实开发中\",{\"1\":{\"50\":1}}],[\"学生\",{\"1\":{\"50\":1}}],[\"主线程\",{\"1\":{\"49\":1}}],[\"<=\",{\"1\":{\"79\":1}}],[\"<=re\",{\"1\":{\"79\":1}}],[\"<word>\",{\"1\":{\"79\":1}}],[\"<\",{\"1\":{\"49\":2,\"79\":1}}],[\"让本地c++方法开启线程\",{\"1\":{\"48\":1}}],[\"调用无参构造函数\",{\"1\":{\"76\":1}}],[\"调用方法或者构造对象\",{\"1\":{\"74\":1}}],[\"调用start方法开启线程\",{\"1\":{\"49\":1}}],[\"调用start方法开启线程执行run方法\",{\"1\":{\"49\":1}}],[\"调用本地方法\",{\"1\":{\"48\":1}}],[\"调整时间\",{\"1\":{\"16\":1}}],[\"文件不存在则创建指定文件\",{\"1\":{\"46\":1}}],[\"文件读取写入\",{\"0\":{\"44\":1}}],[\"关闭输出流\",{\"1\":{\"44\":1}}],[\"关闭输入流\",{\"1\":{\"44\":1}}],[\"关键字修饰字符数组来保存字符串\",{\"1\":{\"31\":1}}],[\"写入一个换行符\",{\"1\":{\"44\":1}}],[\"声明一个字符串变量str\",{\"1\":{\"44\":1}}],[\"字段值\",{\"1\":{\"76\":1}}],[\"字符流\",{\"1\":{\"44\":1}}],[\"字符串结尾\",{\"1\":{\"79\":1}}],[\"字符串结尾或行尾\",{\"1\":{\"79\":1}}],[\"字符串开头\",{\"1\":{\"79\":1}}],[\"字符串常量池的需要\",{\"1\":{\"35\":1}}],[\"字符串\",{\"1\":{\"32\":1}}],[\"字符串格式化\",{\"1\":{\"32\":1}}],[\"字符串中开始查找的位置\",{\"1\":{\"32\":1}}],[\"字符串连接\",{\"1\":{\"32\":1}}],[\"字符串内容是否相同\",{\"1\":{\"32\":1}}],[\"字符串比较\",{\"1\":{\"32\":1}}],[\"字符串长度\",{\"1\":{\"32\":1}}],[\"字符串string\",{\"0\":{\"30\":1}}],[\"字节流\",{\"1\":{\"44\":1}}],[\"字节流和编码表的组合就是字符流\",{\"1\":{\"43\":1}}],[\"信息的最小存储单元都是字节\",{\"1\":{\"43\":1}}],[\"​\",{\"1\":{\"43\":1}}],[\"前者是字节输出流\",{\"1\":{\"42\":1}}],[\"前者是字节输⼊流\",{\"1\":{\"42\":1}}],[\"前者在后者之后返回true\",{\"1\":{\"15\":1}}],[\"所有要通过futuretask适配类\",{\"1\":{\"51\":1}}],[\"所有输出流的基类\",{\"1\":{\"42\":1}}],[\"所有的输⼊流的基类\",{\"1\":{\"42\":1}}],[\"所以正则中\",{\"1\":{\"79\":1}}],[\"所以如果\",{\"1\":{\"60\":1}}],[\"所以call\",{\"1\":{\"51\":1}}],[\"所以它的底层仍然是由数组和链表或红⿊树组成\",{\"1\":{\"18\":1}}],[\"所以在列出枚举值时必须传入对应的参数\",{\"1\":{\"4\":1}}],[\"所以外部无法调用\",{\"1\":{\"4\":1}}],[\"所以可以捕获\",{\"1\":{\"3\":1}}],[\"所以建议仅捕获有必要的代码段\",{\"1\":{\"3\":1}}],[\"按照流的⻆⾊划分为节点流和处理流\",{\"1\":{\"41\":1}}],[\"按照流的流向分\",{\"1\":{\"41\":1}}],[\"按照操作单元划分\",{\"1\":{\"41\":1}}],[\"按n\",{\"1\":{\"32\":1}}],[\"9999\",{\"1\":{\"50\":1}}],[\"9\",{\"1\":{\"39\":1,\"49\":2,\"79\":4}}],[\"例如\",{\"1\":{\"35\":1}}],[\"保证hash\",{\"1\":{\"35\":1}}],[\"移除此序列的子字符串中的字符\",{\"1\":{\"34\":1}}],[\"反射机制是\",{\"1\":{\"74\":1}}],[\"反转字符串\",{\"1\":{\"34\":1}}],[\"反之false\",{\"1\":{\"15\":1}}],[\"追加字符串\",{\"1\":{\"34\":1}}],[\"速度最快线程不安全\",{\"1\":{\"33\":1}}],[\"单线程操作字符串缓冲区下操作大量数据\",{\"1\":{\"33\":1}}],[\"单列\",{\"1\":{\"18\":1}}],[\"则本分组的匹配失败\",{\"1\":{\"79\":1}}],[\"则返回\",{\"1\":{\"76\":1}}],[\"则继续循环\",{\"1\":{\"44\":1}}],[\"则讲该字面量放入常量池\",{\"1\":{\"32\":1}}],[\"则讲堆中对象的引用放入常量池\",{\"1\":{\"32\":1}}],[\"则枚举类的每个实例都必须实现它\",{\"1\":{\"4\":1}}],[\"去堆中查找\",{\"1\":{\"32\":1}}],[\"去字符串前后空格\",{\"1\":{\"32\":1}}],[\"到\",{\"1\":{\"32\":1}}],[\"索引范围为从\",{\"1\":{\"32\":1}}],[\"比懒惰\",{\"1\":{\"79\":1}}],[\"比如获取某个对象的类定义\",{\"1\":{\"74\":1}}],[\"比如汉字\",{\"1\":{\"43\":1}}],[\"比使用+或\",{\"1\":{\"32\":1}}],[\"比较操作可以将其转换为毫秒级的long类型\",{\"1\":{\"12\":1}}],[\"只会被加载一次\",{\"1\":{\"75\":1}}],[\"只锁静态方法\",{\"1\":{\"67\":1}}],[\"只能通过private\",{\"1\":{\"48\":1}}],[\"只有\",{\"1\":{\"35\":1,\"79\":1}}],[\"只用\",{\"1\":{\"32\":1}}],[\"只要把key设置为数字\",{\"1\":{\"21\":1}}],[\"测试此字符串是否以指定的后缀结尾\",{\"1\":{\"32\":1}}],[\"测试此日期是否在指定日期之前\",{\"1\":{\"11\":1}}],[\"测试此日期是否在指定日期之后\",{\"1\":{\"11\":1}}],[\"被替换字符\",{\"1\":{\"32\":1}}],[\"新字符\",{\"1\":{\"32\":1}}],[\"新符号\",{\"1\":{\"32\":1}}],[\"新引入的类localdate\",{\"1\":{\"16\":1}}],[\"x\",{\"1\":{\"79\":1}}],[\"xxx\",{\"1\":{\"32\":1,\"50\":4,\"73\":2}}],[\"xexception\",{\"1\":{\"3\":1}}],[\"号拼接字符串\",{\"1\":{\"31\":1}}],[\"其中的每一个方法实际上是声明了一个配置参数\",{\"1\":{\"74\":1}}],[\"其他线程则无法访问和修改\",{\"1\":{\"57\":1}}],[\"其实就是通过接口注入比较元素大小的算法\",{\"1\":{\"29\":1}}],[\"其限制在\",{\"1\":{\"12\":1}}],[\"参数\",{\"1\":{\"76\":1}}],[\"参数名\",{\"1\":{\"74\":1}}],[\"参数类型\",{\"1\":{\"74\":1}}],[\"参数是comparator\",{\"1\":{\"29\":1}}],[\"参数表示1970\",{\"1\":{\"10\":1}}],[\"第二个小括号是分组2\",{\"1\":{\"79\":1}}],[\"第二种不强制性的要求容器中的元素必须可比较\",{\"1\":{\"29\":1}}],[\"第一个小括号是分组1\",{\"1\":{\"79\":1}}],[\"第一种要求传入的待排序容器中存放的对象比较实现\",{\"1\":{\"29\":1}}],[\"第一次调用iterator的next\",{\"1\":{\"25\":1}}],[\"第一行记录原始数组的行\",{\"1\":{\"5\":1}}],[\"工具类的\",{\"1\":{\"29\":1}}],[\"素进行排序\",{\"1\":{\"29\":1}}],[\"较元素的\",{\"1\":{\"29\":1}}],[\"序\",{\"1\":{\"29\":1}}],[\"提高synchronized同\",{\"1\":{\"69\":1}}],[\"提升n倍\",{\"1\":{\"29\":1}}],[\"提⾼并发访问率\",{\"1\":{\"29\":1}}],[\"⾥包含⼀个\",{\"1\":{\"29\":1}}],[\"⼀个\",{\"1\":{\"29\":2}}],[\"据段的数据\",{\"1\":{\"29\":1}}],[\"低下\",{\"1\":{\"29\":1}}],[\"效率高\",{\"1\":{\"51\":1}}],[\"效率⼜\",{\"1\":{\"29\":1}}],[\"效率⾮常\",{\"1\":{\"29\":1}}],[\"效率低\",{\"1\":{\"18\":2}}],[\"同一个字节码文件\",{\"1\":{\"75\":1}}],[\"同步监视器\",{\"1\":{\"68\":1}}],[\"同步代码块\",{\"1\":{\"68\":1}}],[\"同步方法中无需指定\",{\"1\":{\"68\":1}}],[\"同步方法\",{\"1\":{\"68\":1}}],[\"同步锁会升级为重量级锁\",{\"1\":{\"69\":1}}],[\"同步锁\",{\"0\":{\"63\":1}}],[\"同⼀把锁\",{\"1\":{\"29\":1}}],[\"同时通过对链表进⾏相应的操作\",{\"1\":{\"18\":1}}],[\"就从哪里启用\",{\"1\":{\"79\":1}}],[\"就不会产⽣并发\",{\"1\":{\"29\":1}}],[\"就不会存在锁竞争\",{\"1\":{\"29\":1}}],[\"就判断该元素与要存⼊的元素的\",{\"1\":{\"27\":1}}],[\"就像数组索引一样\",{\"1\":{\"4\":1}}],[\"指明两项之间的一个选择\",{\"1\":{\"79\":1}}],[\"指令后\",{\"0\":{\"65\":1}}],[\"指令时\",{\"0\":{\"65\":1}}],[\"指\",{\"0\":{\"65\":1}}],[\"指的是数组的⻓度\",{\"1\":{\"27\":1}}],[\"指定索引处的字符\",{\"1\":{\"32\":1}}],[\"指定索引复制\",{\"1\":{\"5\":1}}],[\"指定下标的对象\",{\"1\":{\"19\":1}}],[\"处理办法\",{\"1\":{\"61\":1}}],[\"处理过后得到\",{\"1\":{\"27\":1}}],[\"处插入\",{\"1\":{\"18\":1}}],[\"通常情况下\",{\"1\":{\"57\":1}}],[\"通过反射操作指定对象的指定字段\",{\"1\":{\"76\":1}}],[\"通过反射执行指定对象的指定方法\",{\"1\":{\"76\":1}}],[\"通过反射我们可以直接操作类或者对象\",{\"1\":{\"74\":1}}],[\"通过\",{\"1\":{\"27\":1}}],[\"通用\",{\"1\":{\"16\":1}}],[\"链表散列\",{\"1\":{\"27\":1}}],[\"底层是\",{\"1\":{\"27\":1}}],[\"底层采⽤\",{\"1\":{\"18\":1}}],[\"之外的任何字符\",{\"1\":{\"79\":1}}],[\"之前\",{\"1\":{\"27\":1}}],[\"之后每次扩充\",{\"1\":{\"21\":1}}],[\"要的性能消耗\",{\"1\":{\"69\":1}}],[\"要指定泛型\",{\"1\":{\"51\":1}}],[\"要求存放的键值对映射的键必须实现\",{\"1\":{\"29\":1}}],[\"要求存放的对象所属的类必须实现\",{\"1\":{\"29\":1}}],[\"要求容器返回一个iterator\",{\"1\":{\"25\":1}}],[\"要先排序\",{\"1\":{\"5\":1}}],[\"迭代器\",{\"0\":{\"25\":1}}],[\"键\",{\"1\":{\"24\":1}}],[\"键不能重复\",{\"1\":{\"22\":1}}],[\"k<word>\",{\"1\":{\"79\":1}}],[\"k\",{\"1\":{\"24\":2}}],[\"key=\",{\"1\":{\"24\":2}}],[\"keyset是键的集合\",{\"1\":{\"24\":1}}],[\"keyset\",{\"1\":{\"24\":2}}],[\"key\",{\"1\":{\"22\":1,\"24\":4,\"27\":2,\"35\":1,\"59\":1,\"60\":3}}],[\"循环时每次读取一行文本\",{\"1\":{\"44\":1}}],[\"循环\",{\"0\":{\"24\":1}}],[\"循环里进行元素的\",{\"1\":{\"18\":1}}],[\"张三\",{\"1\":{\"22\":1}}],[\"张艺兴\",{\"1\":{\"5\":1}}],[\"内存泄露问题\",{\"0\":{\"60\":1}}],[\"内存放不下\",{\"1\":{\"21\":1}}],[\"内部维护的是㇐个类似\",{\"1\":{\"59\":1}}],[\"内部类\",{\"1\":{\"50\":1}}],[\"内部char数组长度为构建时初始字符串长度加\",{\"1\":{\"33\":1}}],[\"内部的⽅法\",{\"1\":{\"21\":1}}],[\"是\",{\"1\":{\"79\":1}}],[\"是强引用\",{\"1\":{\"60\":1}}],[\"是强引⽤\",{\"1\":{\"60\":1}}],[\"是不可变的\",{\"1\":{\"31\":1,\"35\":1}}],[\"是⼀个链表结构的元素\",{\"1\":{\"29\":1}}],[\"是否相同\",{\"1\":{\"27\":1}}],[\"是否需要定义成\",{\"1\":{\"3\":1}}],[\"是线程安全的\",{\"1\":{\"21\":1}}],[\"为\",{\"1\":{\"60\":2}}],[\"为当前对象的threadlocal\",{\"1\":{\"59\":1}}],[\"为什么还要有字符流\",{\"0\":{\"43\":1}}],[\"为什么是2的幂次⽅\",{\"1\":{\"21\":1}}],[\"为字符或正则\",{\"1\":{\"32\":1}}],[\"为该数组\",{\"1\":{\"5\":1}}],[\"运算效率高\",{\"1\":{\"21\":1}}],[\"得到的余数才能⽤来要存放\",{\"1\":{\"21\":1}}],[\"得到的list只有一个元素\",{\"1\":{\"5\":1}}],[\"~\",{\"1\":{\"21\":1}}],[\"^0\",{\"1\":{\"79\":1}}],[\"^\",{\"1\":{\"21\":2,\"79\":3}}],[\"⽅法⽤来排序\",{\"1\":{\"29\":1}}],[\"⽅法⽤来排\",{\"1\":{\"29\":1}}],[\"⽅\",{\"1\":{\"21\":1}}],[\"需要进行转义才能匹配到\",{\"1\":{\"79\":1}}],[\"需要显式被唤\",{\"1\":{\"53\":1}}],[\"需要重写\",{\"1\":{\"29\":1}}],[\"需要存储的元素个数\",{\"1\":{\"21\":1}}],[\"需要对\",{\"1\":{\"18\":1}}],[\"认值\",{\"1\":{\"21\":1}}],[\"初始化\",{\"1\":{\"21\":1}}],[\"达到阀值则扩容为原来的两倍\",{\"1\":{\"21\":1}}],[\"容量变为原来的\",{\"1\":{\"21\":1}}],[\"容量\",{\"1\":{\"21\":1}}],[\"阀值的计算公式是\",{\"1\":{\"21\":1}}],[\"若两边都是字面字符常量会在编译期就合并了\",{\"1\":{\"31\":1}}],[\"若重复则调用equals\",{\"1\":{\"21\":1}}],[\"若无重复则对象不存在\",{\"1\":{\"21\":1}}],[\"若强转其它类型数组将出现classcastexception\",{\"1\":{\"18\":1}}],[\"遍历时就是从小到大输出了\",{\"1\":{\"21\":1}}],[\"遍历的同时要进行修改使用迭代器\",{\"1\":{\"21\":1}}],[\"遍历\",{\"0\":{\"21\":1,\"23\":1}}],[\"依赖boxed的装箱操作\",{\"1\":{\"20\":1}}],[\"基类\",{\"0\":{\"42\":1}}],[\"基本都经过\",{\"1\":{\"21\":1}}],[\"基本类型也可以实现转换\",{\"1\":{\"20\":1}}],[\"基于\",{\"1\":{\"18\":1}}],[\"正向和负向\",{\"1\":{\"79\":1}}],[\"正常的线程都是用户线程\",{\"1\":{\"55\":1}}],[\"正常编写属性和方法\",{\"1\":{\"50\":1}}],[\"正则表达式的标记用于指定额外的匹配策略\",{\"1\":{\"79\":1}}],[\"正则表达式有另一条规则\",{\"1\":{\"79\":1}}],[\"正则表达式\",{\"0\":{\"79\":1}}],[\"正则\",{\"1\":{\"32\":1}}],[\"正确的将数组转换为arraylist\",{\"0\":{\"20\":1}}],[\"正在变大的情况下\",{\"1\":{\"18\":1}}],[\"替换只能用字符\",{\"1\":{\"32\":1}}],[\"替换可字符可正则\",{\"1\":{\"32\":1}}],[\"替换\",{\"1\":{\"19\":1}}],[\"大小写字母\",{\"1\":{\"79\":1}}],[\"大小\",{\"1\":{\"19\":1}}],[\"大于\",{\"1\":{\"18\":2}}],[\"大于1\",{\"1\":{\"15\":1}}],[\"清空arraylist\",{\"1\":{\"19\":1}}],[\">=\",{\"1\":{\"37\":1}}],[\">system\",{\"1\":{\"21\":1,\"24\":1}}],[\">\",{\"1\":{\"19\":1,\"50\":3}}],[\">date\",{\"1\":{\"10\":1}}],[\"删除\",{\"1\":{\"46\":1}}],[\"删除指定对象\",{\"1\":{\"19\":1}}],[\"删除指定位置上的元素\",{\"1\":{\"19\":1}}],[\"删除元素的条件\",{\"1\":{\"18\":1}}],[\"添加元素到列表结尾\",{\"1\":{\"19\":1}}],[\"添加元素到列表开头\",{\"1\":{\"19\":1}}],[\"添加元素\",{\"1\":{\"19\":1}}],[\"苹果\",{\"1\":{\"19\":1}}],[\"创建指定规则的正则对象\",{\"1\":{\"79\":1}}],[\"创建指定目录\",{\"1\":{\"46\":2}}],[\"创建线程\",{\"1\":{\"52\":1}}],[\"创建一个线程对象\",{\"1\":{\"49\":1}}],[\"创建一个字符输出缓冲流对象\",{\"1\":{\"44\":1}}],[\"创建一个字符输入缓冲流对象\",{\"1\":{\"44\":1}}],[\"创建对象\",{\"1\":{\"49\":1}}],[\"创建5个\",{\"1\":{\"35\":1}}],[\"创建不可变的list\",{\"1\":{\"19\":1}}],[\"创建calendar对象\",{\"0\":{\"8\":1}}],[\"把数组转换成集合时\",{\"1\":{\"18\":1}}],[\"方\",{\"0\":{\"66\":1}}],[\"方便下次写入\",{\"1\":{\"44\":1}}],[\"方式\",{\"1\":{\"18\":1}}],[\"方法参数值\",{\"1\":{\"76\":1}}],[\"方法参数\",{\"1\":{\"76\":1}}],[\"方法的名称就是参数的名称\",{\"1\":{\"74\":1}}],[\"方法初始化值\",{\"1\":{\"57\":1}}],[\"方法只执行了一次\",{\"1\":{\"51\":1}}],[\"方法执行中\",{\"1\":{\"51\":2}}],[\"方法获取callable接口call方法的返回值\",{\"1\":{\"51\":1}}],[\"方法获取实例\",{\"1\":{\"8\":1}}],[\"方法开启的子线程不一定立即执行\",{\"1\":{\"49\":1}}],[\"方法节省内存\",{\"1\":{\"32\":1}}],[\"方法用于检测字符串是否以指定的前缀开始\",{\"1\":{\"32\":1}}],[\"方法拼接然后进行\",{\"1\":{\"31\":1}}],[\"方法实现元素的比较\",{\"1\":{\"29\":1}}],[\"方法有两种重载的形式\",{\"1\":{\"29\":1}}],[\"方法时返回序列的第一个元素\",{\"1\":{\"25\":1}}],[\"方法判断是否真的相同\",{\"1\":{\"21\":1}}],[\"方法会抛出\",{\"1\":{\"18\":1}}],[\"方法全部使用synchronized修饰线程安全\",{\"1\":{\"18\":2}}],[\"方法指定时间\",{\"1\":{\"16\":1}}],[\"方法和构造函数\",{\"1\":{\"4\":1}}],[\"方法\",{\"0\":{\"19\":1,\"22\":1},\"1\":{\"4\":2,\"16\":2,\"18\":1,\"21\":1,\"29\":1,\"76\":1}}],[\"方法返回指定字符串值的枚举常量\",{\"1\":{\"4\":1}}],[\"方法可以找到每个枚举常量的索引\",{\"1\":{\"4\":1}}],[\"方法位于\",{\"1\":{\"4\":1}}],[\"会抛出concurrentmodificationexception异常\",{\"1\":{\"18\":1}}],[\"会在add\",{\"1\":{\"18\":1}}],[\"操作中如果除数是2的幂次则等价于与其除数减⼀的与\",{\"1\":{\"21\":1}}],[\"操作\",{\"1\":{\"18\":1,\"21\":1,\"69\":1}}],[\"因此只需要进行一次计算\",{\"1\":{\"35\":1}}],[\"因此要对hash的⻓度取模运算\",{\"1\":{\"21\":1}}],[\"因此最好在创建\",{\"1\":{\"18\":1}}],[\"因为同步方法的同步监视器就是this即对象本身\",{\"1\":{\"68\":1}}],[\"因为jvm无法进行cpu的调度\",{\"1\":{\"53\":1}}],[\"因为java运行在虚拟机上无法直接操作硬件\",{\"1\":{\"48\":1}}],[\"因为thread不能直接\",{\"1\":{\"51\":1}}],[\"因为\",{\"1\":{\"35\":1}}],[\"因为二进制操作比\",{\"1\":{\"21\":1}}],[\"因为已经定义了带参数的构造器\",{\"1\":{\"4\":1}}],[\"因为那样可能导致潜在的安全问题\",{\"1\":{\"3\":1}}],[\"因为这种类型设计的初衷更是为了从异常情况恢复\",{\"1\":{\"3\":1}}],[\"扩容操作将原数组整个复制到新数组中\",{\"1\":{\"18\":1}}],[\"具体为int\",{\"1\":{\"18\":1}}],[\"隐患\",{\"1\":{\"18\":1}}],[\"存在于\",{\"1\":{\"67\":1}}],[\"存在\",{\"1\":{\"18\":1}}],[\"值为\",{\"1\":{\"59\":1}}],[\"值也不可变\",{\"1\":{\"35\":1}}],[\"值经常被使用\",{\"1\":{\"35\":1}}],[\"值相同\",{\"1\":{\"35\":1}}],[\"值以及\",{\"1\":{\"27\":1}}],[\"值可以重复\",{\"1\":{\"22\":1}}],[\"值\",{\"1\":{\"18\":1,\"24\":1}}],[\"且分锁交替切换的场景\",{\"1\":{\"69\":1}}],[\"且在\",{\"1\":{\"18\":1}}],[\"且所有的枚举值都是\",{\"1\":{\"4\":1}}],[\"空间浪费\",{\"1\":{\"18\":1}}],[\"空指针异常\",{\"1\":{\"3\":1}}],[\"负载因子\",{\"1\":{\"21\":1}}],[\"负面影响与\",{\"1\":{\"18\":1}}],[\"负担\",{\"1\":{\"18\":1}}],[\"增加\",{\"1\":{\"18\":1}}],[\"增加了⼀条双向链\",{\"1\":{\"18\":1}}],[\"重复n次以上\",{\"1\":{\"79\":1}}],[\"重复n到m次\",{\"1\":{\"79\":1}}],[\"重复0次或1次\",{\"1\":{\"79\":1}}],[\"重复1次或更多次\",{\"1\":{\"79\":1}}],[\"重复任意次\",{\"1\":{\"79\":1}}],[\"重量级锁\",{\"1\":{\"69\":1}}],[\"重写threadpoolexecutor的afterexecute\",{\"1\":{\"61\":1}}],[\"重写tostring\",{\"1\":{\"4\":1}}],[\"重写call方法\",{\"1\":{\"51\":1}}],[\"重写run方法\",{\"1\":{\"49\":1,\"50\":1}}],[\"重新创建大小等于\",{\"1\":{\"18\":1}}],[\"性能最好\",{\"1\":{\"18\":2}}],[\"相应的在执⾏monitorexit\",{\"0\":{\"65\":1}}],[\"相互转换\",{\"1\":{\"51\":1}}],[\"相当于\",{\"1\":{\"31\":1}}],[\"相当于一个临时定义的排序规则\",{\"1\":{\"29\":1}}],[\"相同\",{\"1\":{\"18\":1}}],[\"相同的数组\",{\"1\":{\"18\":2}}],[\"相等\",{\"1\":{\"15\":1}}],[\"动态创建与\",{\"1\":{\"18\":2}}],[\"动态初始化\",{\"1\":{\"5\":1}}],[\"等元字符\",{\"1\":{\"79\":1}}],[\"等待a线程运行结束后\",{\"1\":{\"52\":1}}],[\"等价于\",{\"1\":{\"21\":1,\"79\":4}}],[\"等于\",{\"1\":{\"18\":3}}],[\"等都是\",{\"1\":{\"18\":1}}],[\"错误\",{\"1\":{\"18\":1}}],[\"此方法返回值只能是\",{\"1\":{\"18\":1}}],[\"无法修改实体类时\",{\"1\":{\"29\":1}}],[\"无参方法存在问题\",{\"1\":{\"18\":1}}],[\"无add等方法\",{\"1\":{\"5\":1}}],[\"长度为\",{\"1\":{\"18\":1}}],[\"致\",{\"1\":{\"18\":1}}],[\"传入的是和返回类型完全一\",{\"1\":{\"18\":1}}],[\"传递的数组必须是对象数组\",{\"1\":{\"5\":1}}],[\"必须启用case\",{\"1\":{\"79\":1}}],[\"必须使用集合的\",{\"1\":{\"18\":1}}],[\"必须符合\",{\"1\":{\"15\":1}}],[\"判断字符串是否匹配规则\",{\"1\":{\"79\":1}}],[\"判断字符串是否为数字\",{\"0\":{\"36\":1}}],[\"判断字符串是否为空\",{\"1\":{\"32\":1}}],[\"判断file对象对应的文件或目录是否存在\",{\"1\":{\"46\":1}}],[\"判断是否为文件\",{\"1\":{\"46\":1}}],[\"判断是否包含某个value值\",{\"1\":{\"22\":1}}],[\"判断是否包含某个key值\",{\"1\":{\"22\":1}}],[\"判断arraylist是否为空\",{\"1\":{\"19\":1}}],[\"判断集合中是否存在苹果\",{\"1\":{\"19\":1}}],[\"判断所有集合内部的元素是否为空\",{\"1\":{\"18\":1}}],[\"判断数组中是否包含a\",{\"1\":{\"5\":1}}],[\"顺序相关逻辑\",{\"1\":{\"18\":1}}],[\"使边界字符\",{\"1\":{\"79\":1}}],[\"使匹配更精准\",{\"1\":{\"79\":1}}],[\"使⽤\",{\"1\":{\"29\":1}}],[\"使得上⾯的结构可以保持键值对的插⼊顺序\",{\"1\":{\"18\":1}}],[\"使用synchronized修饰\",{\"1\":{\"68\":1}}],[\"使用方式\",{\"0\":{\"68\":1}}],[\"使用方法iterator\",{\"1\":{\"25\":1}}],[\"使用线程池或直接复用线程时\",{\"1\":{\"61\":1}}],[\"使用一个标志位来停止线程\",{\"1\":{\"56\":1}}],[\"使用lambda表达式\",{\"1\":{\"50\":1}}],[\"使用lang3下的包下stringutils类的方法isnumeric\",{\"0\":{\"38\":1}}],[\"使用long类型风格的formatstyle\",{\"1\":{\"17\":1}}],[\"使用给定\",{\"1\":{\"34\":1}}],[\"使用了同步锁速度较慢线程安全\",{\"1\":{\"33\":1}}],[\"使用remove\",{\"1\":{\"25\":1}}],[\"使用hasnext\",{\"1\":{\"25\":1}}],[\"使用next\",{\"1\":{\"25\":1}}],[\"使用now\",{\"1\":{\"16\":1}}],[\"使用工具类\",{\"1\":{\"18\":1}}],[\"使用集合转数组的方法\",{\"1\":{\"18\":1}}],[\"使用\",{\"1\":{\"18\":1,\"20\":1,\"21\":1,\"24\":1,\"31\":1}}],[\"使用常量创建\",{\"1\":{\"17\":1}}],[\"使用of\",{\"1\":{\"16\":1}}],[\"使用joda\",{\"1\":{\"12\":1}}],[\"使用的是父类的引用\",{\"1\":{\"3\":1}}],[\"表示分组word匹配的文本\",{\"1\":{\"79\":1}}],[\"表示分组1匹配的文本\",{\"1\":{\"79\":1}}],[\"表示定义了一个叫做word的分组\",{\"1\":{\"79\":2}}],[\"表示object\",{\"1\":{\"76\":1}}],[\"表示匹配路径为com\",{\"1\":{\"74\":1}}],[\"表示需要在什么级别保存该注释信息\",{\"1\":{\"73\":1}}],[\"表示废弃\",{\"1\":{\"72\":1}}],[\"表示为重写\",{\"1\":{\"72\":1}}],[\"表\",{\"1\":{\"18\":1}}],[\"另外\",{\"1\":{\"18\":1}}],[\"继承thread类\",{\"0\":{\"49\":1},\"1\":{\"49\":1}}],[\"继承⾃\",{\"1\":{\"18\":1}}],[\"继承于\",{\"1\":{\"18\":1}}],[\"将匹配设置为不区分大小写\",{\"1\":{\"79\":1}}],[\"将锁计数器减一\",{\"0\":{\"65\":1}}],[\"将读取到的一行字符串写入到文件中\",{\"1\":{\"44\":1}}],[\"将xxx转换为string类型\",{\"1\":{\"32\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"28\":1}}],[\"将链表转化为红⿊树\",{\"1\":{\"18\":1}}],[\"将迭代器新返回的元素删除\",{\"1\":{\"25\":1}}],[\"将数据put到hashmap后\",{\"1\":{\"21\":1}}],[\"将数组a中元素全部填充为0\",{\"1\":{\"5\":1}}],[\"将集合中所有元素插入该集合指定位置\",{\"1\":{\"19\":1}}],[\"将集合中所有元素插入该集合末尾\",{\"1\":{\"19\":1}}],[\"当html内容不规范\",{\"1\":{\"79\":1}}],[\"当一个线程获取锁时\",{\"1\":{\"69\":1}}],[\"当一个数组中大部分元素为0或同一个值时\",{\"1\":{\"5\":1}}],[\"当使用string作为监视器时\",{\"1\":{\"68\":1}}],[\"当方法不管是正常return还是抛出异常都会释放\",{\"0\":{\"66\":1}}],[\"当计数器为0\",{\"0\":{\"65\":1}}],[\"当计数器为0则可以成功获取\",{\"0\":{\"65\":1}}],[\"当执⾏monitorenter\",{\"0\":{\"65\":1}}],[\"当调用\",{\"1\":{\"60\":1}}],[\"当父目录不存在时一起创建\",{\"1\":{\"46\":1}}],[\"当插入元素时会回调该方法比较元素的大小\",{\"1\":{\"29\":1}}],[\"当链表的长度大于阈值\",{\"1\":{\"28\":1}}],[\"当链表⻓度⼤于阈值\",{\"1\":{\"18\":1}}],[\"双列键值对\",{\"1\":{\"18\":1}}],[\"双向链表\",{\"1\":{\"18\":1}}],[\"⾃平衡的排序⼆叉树\",{\"1\":{\"18\":2}}],[\"红⿊树\",{\"1\":{\"18\":2}}],[\"并压入堆栈\",{\"1\":{\"79\":1}}],[\"并对外提供一个修改标识的方法\",{\"1\":{\"56\":1}}],[\"并且使用\",{\"1\":{\"79\":1}}],[\"并且使用时value可不写\",{\"1\":{\"74\":1}}],[\"并且统一暴露为runnable可运行的\",{\"1\":{\"53\":1}}],[\"并且新建一个\",{\"1\":{\"35\":1}}],[\"并且其内部是通过\",{\"1\":{\"18\":1}}],[\"并返回该引用\",{\"1\":{\"32\":1}}],[\"并发控制使⽤\",{\"1\":{\"29\":1}}],[\"并实现了\",{\"1\":{\"4\":1}}],[\"唯⼀\",{\"1\":{\"18\":2}}],[\"唯一庆幸的是\",{\"1\":{\"0\":1}}],[\"⽆序\",{\"1\":{\"18\":1}}],[\"线程试图获取锁也就是获取\",{\"0\":{\"65\":1}}],[\"线程同步\",{\"0\":{\"62\":1}}],[\"线程执行前将threadlocal\",{\"1\":{\"61\":1}}],[\"线程复用问题\",{\"0\":{\"61\":1}}],[\"线程将threadlocal作为key从\",{\"1\":{\"59\":1}}],[\"线程优先级priority\",{\"0\":{\"54\":1}}],[\"线程状态\",{\"0\":{\"53\":1}}],[\"线程让出cpu\",{\"1\":{\"52\":1}}],[\"线程休眠200毫秒\",{\"1\":{\"52\":1}}],[\"线程中断并不会使线程立即退出\",{\"1\":{\"52\":1}}],[\"线程名\",{\"1\":{\"52\":1}}],[\"线程c\",{\"1\":{\"50\":1}}],[\"线程b\",{\"1\":{\"50\":1}}],[\"线程a\",{\"1\":{\"50\":1}}],[\"线程创建\",{\"0\":{\"48\":1}}],[\"线程不安全\",{\"1\":{\"18\":2}}],[\"线程安全性\",{\"1\":{\"35\":1}}],[\"线程安全\",{\"1\":{\"17\":1,\"33\":1}}],[\"有返回值\",{\"1\":{\"51\":1}}],[\"有了编码表可以确定这个汉字有多少个字节\",{\"1\":{\"43\":1}}],[\"有相同引用的对象\",{\"1\":{\"19\":1}}],[\"有序\",{\"1\":{\"18\":2}}],[\"有效值的个数\",{\"1\":{\"5\":1}}],[\"集合collection\",{\"0\":{\"18\":1}}],[\"三种实例化方式\",{\"1\":{\"17\":1}}],[\"实例需要在多个方法中共享\",{\"1\":{\"58\":1}}],[\"实例化方式\",{\"1\":{\"16\":1}}],[\"实际上就是做减法从第一个不相同的字符开始比\",{\"1\":{\"32\":1}}],[\"实现原理\",{\"0\":{\"64\":1}}],[\"实现了线程的数据隔离\",{\"1\":{\"57\":1}}],[\"实现了访问\",{\"1\":{\"18\":1}}],[\"实现callable接口\",{\"0\":{\"51\":1},\"1\":{\"51\":1}}],[\"实现runnable接口\",{\"0\":{\"50\":1}}],[\"实现线程安全的区别\",{\"0\":{\"29\":1}}],[\"实现的\",{\"1\":{\"18\":1}}],[\"实话实说\",{\"1\":{\"0\":1}}],[\"即到了文件末尾\",{\"1\":{\"44\":1}}],[\"即可以将它看成一个字符\",{\"1\":{\"79\":1}}],[\"即可\",{\"1\":{\"21\":1}}],[\"即16\",{\"1\":{\"21\":1}}],[\"即数据库的驱动版本不低于4\",{\"1\":{\"16\":1}}],[\"即时间戳\",{\"1\":{\"15\":1}}],[\"加上\",{\"1\":{\"79\":1}}],[\"加载因子\",{\"1\":{\"21\":1}}],[\"加了5小时10分钟\",{\"1\":{\"15\":1}}],[\"加法\",{\"1\":{\"15\":1}}],[\"小于\",{\"1\":{\"15\":1}}],[\"小时\",{\"1\":{\"12\":1}}],[\"小猪\",{\"1\":{\"5\":1}}],[\"天\",{\"1\":{\"12\":1}}],[\"获得序列中的下一个元素\",{\"1\":{\"25\":1}}],[\"获得两个时间的毫秒时间差异\",{\"1\":{\"12\":1}}],[\"获取matcher对象\",{\"1\":{\"79\":1}}],[\"获取注解属性的值\",{\"1\":{\"78\":1}}],[\"获取注解信息\",{\"0\":{\"78\":1}}],[\"获取类上指定注解\",{\"1\":{\"78\":1}}],[\"获取类声明的属性和方法\",{\"1\":{\"74\":1}}],[\"获取字段上指定注解\",{\"1\":{\"78\":1}}],[\"获取全部的注解\",{\"1\":{\"78\":1}}],[\"获取泛型\",{\"1\":{\"77\":1}}],[\"获取方法返回值类型\",{\"1\":{\"77\":1}}],[\"获取方法参数类型\",{\"1\":{\"77\":1}}],[\"获取方法泛型信息\",{\"0\":{\"77\":1}}],[\"获取本类的所有方法\",{\"1\":{\"76\":1}}],[\"获取本类和父类的所有public方法\",{\"1\":{\"76\":1}}],[\"获取该类所有的public的构造函数\",{\"1\":{\"76\":1}}],[\"获取简单的类名\",{\"1\":{\"76\":1}}],[\"获取后将锁\",{\"0\":{\"65\":1}}],[\"获取线程名\",{\"1\":{\"52\":1}}],[\"获取线程优先级\",{\"1\":{\"52\":1}}],[\"获取class对象\",{\"0\":{\"75\":1}}],[\"获取clock对应日期\",{\"1\":{\"16\":1}}],[\"获取callable的返回结果\",{\"1\":{\"51\":1}}],[\"获取文件最后一次修改时间\",{\"1\":{\"46\":1}}],[\"获取文件名\",{\"1\":{\"46\":1}}],[\"获取子字符串\",{\"1\":{\"32\":1}}],[\"获取对象位置\",{\"1\":{\"19\":1}}],[\"获取元素\",{\"1\":{\"19\":1}}],[\"获取某年的天数\",{\"1\":{\"16\":1}}],[\"获取xxx\",{\"1\":{\"16\":1}}],[\"获取当前class对象的接口\",{\"1\":{\"76\":1}}],[\"获取当前的线程\",{\"1\":{\"52\":1}}],[\"获取当前日期\",{\"1\":{\"16\":1}}],[\"获取当前时间\",{\"1\":{\"15\":1}}],[\"获取utc时区转换的毫秒数\",{\"1\":{\"14\":1}}],[\"获取utc时区转换的当前时间\",{\"1\":{\"14\":1}}],[\"获取utc时区\",{\"1\":{\"14\":1}}],[\"获取星期几\",{\"1\":{\"9\":1}}],[\"获取秒\",{\"1\":{\"9\":1}}],[\"获取分\",{\"1\":{\"9\":1}}],[\"获取时\",{\"1\":{\"9\":1}}],[\"获取日\",{\"1\":{\"9\":1}}],[\"获取月\",{\"1\":{\"9\":1}}],[\"获取年\",{\"1\":{\"9\":1}}],[\"获取数组的长度\",{\"1\":{\"5\":1}}],[\"中包含换行符\",{\"1\":{\"79\":2}}],[\"中是取非操作\",{\"1\":{\"79\":1}}],[\"中使⽤的\",{\"1\":{\"60\":1}}],[\"中断线程\",{\"1\":{\"52\":1}}],[\"中断异常\",{\"1\":{\"3\":1}}],[\"中取得引用\",{\"1\":{\"35\":1}}],[\"中的字符替换此序列的子字符串中的字符\",{\"1\":{\"34\":1}}],[\"中对函数式编程的支持\",{\"1\":{\"29\":1}}],[\"中\",{\"1\":{\"12\":1,\"69\":1,\"79\":1}}],[\"可能导致死锁等问题\",{\"1\":{\"68\":1}}],[\"可能会因为call方法没执行完而阻塞\",{\"1\":{\"51\":1}}],[\"可重入锁\",{\"0\":{\"63\":1}}],[\"可将\",{\"1\":{\"12\":1}}],[\"可以通过default来声明参数的默认值\",{\"1\":{\"74\":1}}],[\"可以通过getinstance\",{\"1\":{\"8\":1}}],[\"可以考虑禁用偏向锁和禁用自旋锁\",{\"1\":{\"69\":1}}],[\"可以看做同一个对象\",{\"1\":{\"68\":1}}],[\"可以是任何对象\",{\"1\":{\"68\":1}}],[\"可以实现\",{\"1\":{\"51\":1}}],[\"可以抛出异常\",{\"1\":{\"51\":1}}],[\"可以划分为字节流和字符流\",{\"1\":{\"41\":1}}],[\"可以分为输⼊流和输出流\",{\"1\":{\"41\":1}}],[\"可以使用稀疏数组来保存该数组节省空间\",{\"1\":{\"5\":1}}],[\"减少锁的持有时间\",{\"1\":{\"69\":1}}],[\"减少锁粒度\",{\"1\":{\"69\":1}}],[\"减少锁竞争\",{\"1\":{\"69\":1}}],[\"减少搜索时间\",{\"1\":{\"28\":1}}],[\"减少冲突概率\",{\"1\":{\"27\":1}}],[\"减少扩容操作的次数\",{\"1\":{\"18\":1}}],[\"减少编码量等\",{\"1\":{\"3\":1}}],[\"减法\",{\"1\":{\"15\":1}}],[\"减\",{\"1\":{\"12\":1}}],[\"用于匹配嵌套层次结构\",{\"1\":{\"79\":1}}],[\"用于描述注解的生命周期\",{\"1\":{\"73\":1}}],[\"用于描述注解的使用范围\",{\"1\":{\"73\":1}}],[\"用于自动关闭连接\",{\"1\":{\"3\":1}}],[\"用户态和内核态频繁切换\",{\"1\":{\"69\":1}}],[\"用字节流读取的时候有可能因为一位字节没有读到就变成了乱码\",{\"1\":{\"43\":1}}],[\"用正则表达式\",{\"0\":{\"39\":1}}],[\"用java自带的函数\",{\"0\":{\"37\":1}}],[\"用做\",{\"1\":{\"35\":1}}],[\"用给定的日历字段值设置日历的当前时间值\",{\"1\":{\"11\":2}}],[\"用来对\",{\"1\":{\"11\":2}}],[\"从小到大排序\",{\"1\":{\"21\":1}}],[\"从此列表中删除指定集合中包含的所有元素\",{\"1\":{\"19\":1}}],[\"从历元至现在的毫秒偏移量\",{\"1\":{\"11\":1}}],[\"从历元到现在的毫秒偏移量\",{\"1\":{\"11\":1}}],[\"从0数\",{\"1\":{\"5\":1}}],[\"包括换行符\",{\"1\":{\"79\":1}}],[\"包装类\",{\"1\":{\"75\":1}}],[\"包它有⼀个\",{\"1\":{\"29\":1}}],[\"包含⼀个\",{\"1\":{\"29\":1}}],[\"包提供了\",{\"1\":{\"10\":1}}],[\"包住整段的代码\",{\"1\":{\"3\":1}}],[\"8888\",{\"1\":{\"50\":1}}],[\"8之前\",{\"0\":{\"27\":1,\"28\":1}}],[\"8之前hashmap由数组+链表组成的\",{\"1\":{\"18\":1}}],[\"8以后在解决哈希冲突时有了较⼤的变化\",{\"1\":{\"18\":1}}],[\"8\",{\"1\":{\"9\":1,\"27\":1,\"29\":1,\"49\":2}}],[\"7的时候\",{\"1\":{\"29\":1}}],[\"75f\",{\"1\":{\"21\":1}}],[\"7取消了循环\",{\"1\":{\"18\":1}}],[\"7\",{\"1\":{\"9\":2,\"49\":2}}],[\"秒\",{\"1\":{\"9\":2}}],[\"分组\",{\"1\":{\"79\":1}}],[\"分类\",{\"0\":{\"41\":1}}],[\"分别是堆中的3个\",{\"1\":{\"35\":1}}],[\"分别处理日期\",{\"1\":{\"16\":1}}],[\"分段锁\",{\"1\":{\"29\":1}}],[\"分钟\",{\"1\":{\"12\":1}}],[\"分\",{\"1\":{\"9\":2}}],[\"时表明锁被释放\",{\"0\":{\"65\":1}}],[\"时都会清空key为null的记录\",{\"1\":{\"60\":1}}],[\"时进行判断\",{\"1\":{\"18\":1}}],[\"时刻\",{\"0\":{\"15\":1}}],[\"时钟\",{\"0\":{\"14\":1}}],[\"时间和日期时间\",{\"1\":{\"16\":1}}],[\"时间\",{\"1\":{\"14\":1}}],[\"时间转换成毫秒级的long型\",{\"1\":{\"12\":1}}],[\"时间戳\",{\"0\":{\"15\":1},\"1\":{\"12\":2}}],[\"时间值\",{\"1\":{\"11\":1}}],[\"时\",{\"1\":{\"9\":2,\"18\":1,\"28\":1}}],[\"日\",{\"1\":{\"9\":2}}],[\"日期与时间\",{\"0\":{\"6\":1}}],[\"月\",{\"1\":{\"9\":2}}],[\"月份从0开始\",{\"1\":{\"9\":1}}],[\"以上类型的数组\",{\"1\":{\"74\":1}}],[\"以清除\",{\"1\":{\"61\":1}}],[\"以减少搜索时间\",{\"1\":{\"18\":1}}],[\"以毫秒为单位\",{\"1\":{\"11\":2}}],[\"以此类推\",{\"1\":{\"9\":1}}],[\"以及错误\",{\"1\":{\"3\":1}}],[\"年\",{\"1\":{\"9\":2}}],[\"常用于匹配html标签\",{\"1\":{\"79\":1}}],[\"常用手段\",{\"1\":{\"69\":1}}],[\"常用方法\",{\"0\":{\"9\":1,\"11\":1,\"32\":1,\"34\":1,\"46\":1}}],[\"常量池2个\",{\"1\":{\"35\":1}}],[\"常量池中创建一个\",{\"1\":{\"35\":1}}],[\"常量会被转换为当前枚举对象\",{\"1\":{\"4\":1}}],[\"默认情况下的圆点\",{\"1\":{\"79\":1}}],[\"默认值\",{\"1\":{\"74\":1}}],[\"默认值为基本类型默认值值\",{\"1\":{\"5\":1}}],[\"默认是false表示是用户线程\",{\"1\":{\"55\":1}}],[\"默认是当前日期\",{\"1\":{\"8\":1}}],[\"默认8\",{\"1\":{\"28\":1}}],[\"默认的初始大小为\",{\"1\":{\"21\":1}}],[\"默认容量10\",{\"1\":{\"18\":1}}],[\"默认为8\",{\"1\":{\"18\":1}}],[\"剩余行记录有效值在原始数组的位置和值\",{\"1\":{\"5\":1}}],[\"列\",{\"1\":{\"5\":1}}],[\"稀疏数组是一个n行3列的二维数组\",{\"1\":{\"5\":1}}],[\"复制的长度\",{\"1\":{\"5\":1}}],[\"6之前一直是重量级锁\",{\"1\":{\"69\":1}}],[\"6之前为循环链表\",{\"1\":{\"18\":1}}],[\"6中引入了分级锁机制来优化synchronized\",{\"1\":{\"69\":1}}],[\"60\",{\"1\":{\"12\":5,\"15\":2}}],[\"6\",{\"1\":{\"5\":2,\"9\":2,\"49\":2}}],[\"填充为0\",{\"1\":{\"5\":1}}],[\"二分查找字符c在数组的位置\",{\"1\":{\"5\":1}}],[\"倒序\",{\"1\":{\"5\":1}}],[\"升序\",{\"1\":{\"5\":1}}],[\"u\",{\"1\":{\"79\":1}}],[\"unix\",{\"1\":{\"79\":1}}],[\"unicode\",{\"1\":{\"79\":1}}],[\"universal\",{\"1\":{\"4\":4}}],[\"unsupportedoperationexception\",{\"1\":{\"18\":1,\"24\":1}}],[\"utc格式的字符串\",{\"1\":{\"15\":1}}],[\"util\",{\"1\":{\"5\":2,\"10\":1,\"29\":1}}],[\"而使用\",{\"1\":{\"57\":1}}],[\"而等待是主动的\",{\"1\":{\"53\":1}}],[\"而1的hashcode为1\",{\"1\":{\"21\":1}}],[\"而取余\",{\"1\":{\"21\":1}}],[\"而不是整个字符串的开头和结尾\",{\"1\":{\"79\":1}}],[\"而不是\",{\"1\":{\"18\":1}}],[\"而不是基本类型\",{\"1\":{\"5\":1}}],[\"而是给线程发送一个通知\",{\"1\":{\"52\":1}}],[\"而是\",{\"1\":{\"5\":1}}],[\"而是应该捕获特定异常\",{\"1\":{\"3\":1}}],[\"0作为默认值\",{\"1\":{\"74\":1}}],[\"04\",{\"1\":{\"10\":1}}],[\"08\",{\"1\":{\"10\":1}}],[\"00z\",{\"1\":{\"15\":1}}],[\"00到指定时间的毫秒数\",{\"1\":{\"10\":1}}],[\"00\",{\"1\":{\"10\":2,\"15\":1}}],[\"01t01\",{\"1\":{\"15\":1}}],[\"01\",{\"1\":{\"10\":3,\"15\":1}}],[\"0表示1月份\",{\"1\":{\"9\":1}}],[\"0\",{\"1\":{\"5\":3,\"15\":1,\"18\":5,\"19\":2,\"21\":1,\"32\":1,\"37\":1,\"39\":1,\"44\":1,\"49\":4,\"79\":4}}],[\"返回所有属性\",{\"1\":{\"76\":1}}],[\"返回public的属性\",{\"1\":{\"76\":1}}],[\"返回只能方法名和参数类型的方法\",{\"1\":{\"76\":1}}],[\"返回该类的类加载器\",{\"1\":{\"76\":1}}],[\"返回该常量的引用\",{\"1\":{\"32\":1}}],[\"返回当前class对象的父类的class对象\",{\"1\":{\"76\":1}}],[\"返回class对象的一个实例\",{\"1\":{\"76\":1}}],[\"返回指定类名name的class对象\",{\"1\":{\"76\":1}}],[\"返回指定字符在此字符串中第一次出现处的索引\",{\"1\":{\"32\":1}}],[\"返回值只能是基本类型\",{\"1\":{\"74\":1}}],[\"返回值类型就是参数的类型\",{\"1\":{\"74\":1}}],[\"返回子文件和子目录的file数组\",{\"1\":{\"46\":1}}],[\"返回最前的下标\",{\"1\":{\"19\":1}}],[\"返回减去对应值的时间\",{\"1\":{\"16\":1}}],[\"返回加上对应值的时间\",{\"1\":{\"16\":1}}],[\"返回新设置的时间\",{\"1\":{\"16\":1}}],[\"返回此class对象所表示的实体\",{\"1\":{\"76\":1}}],[\"返回此列表中最后出现的指定元素的索引\",{\"1\":{\"19\":1}}],[\"返回此列表中首次出现的指定元素的索引\",{\"1\":{\"19\":1}}],[\"返回此\",{\"1\":{\"11\":3}}],[\"返回一个表示此\",{\"1\":{\"11\":1}}],[\"返回一个表示此对象表示的日期的毫秒数\",{\"1\":{\"11\":1}}],[\"返回的并不是\",{\"1\":{\"5\":1}}],[\"返回某行列数即2\",{\"1\":{\"5\":1}}],[\"返回行数即3\",{\"1\":{\"5\":1}}],[\"返回枚举类中所有的值\",{\"1\":{\"4\":1}}],[\"lnherited\",{\"1\":{\"73\":1}}],[\"len\",{\"1\":{\"44\":3}}],[\"lengthofyear\",{\"1\":{\"16\":1}}],[\"length\",{\"1\":{\"5\":3,\"32\":2,\"37\":1}}],[\"lastmodified\",{\"1\":{\"46\":1}}],[\"lastindexof\",{\"1\":{\"19\":1}}],[\"lang包\",{\"1\":{\"29\":1}}],[\"lang\",{\"1\":{\"4\":4}}],[\"lines\",{\"1\":{\"79\":1}}],[\"linkedhashmap\",{\"1\":{\"18\":3}}],[\"linkedhashmap来实现的\",{\"1\":{\"18\":1}}],[\"linkedhashset\",{\"1\":{\"18\":2}}],[\"linkedlist\",{\"1\":{\"18\":1,\"19\":8}}],[\"listfiles\",{\"1\":{\"46\":1}}],[\"list<string>\",{\"1\":{\"18\":2,\"21\":1}}],[\"list\",{\"1\":{\"18\":10,\"19\":2,\"20\":4}}],[\"lock接口的实现类\",{\"1\":{\"70\":1}}],[\"lock\",{\"0\":{\"70\":1}}],[\"localhost\",{\"1\":{\"50\":1}}],[\"localdatetime\",{\"1\":{\"16\":2}}],[\"localdate\",{\"1\":{\"16\":4}}],[\"localtime和localdatetime\",{\"1\":{\"16\":1}}],[\"localxxx\",{\"0\":{\"16\":1}}],[\"long\",{\"1\":{\"10\":1,\"11\":4,\"12\":9,\"17\":1}}],[\"黄磊\",{\"1\":{\"5\":1}}],[\"黄渤\",{\"1\":{\"5\":1}}],[\"牙哥\",{\"1\":{\"5\":1}}],[\"孙红雷\",{\"1\":{\"5\":1}}],[\"5555\",{\"1\":{\"50\":1}}],[\"5倍\",{\"1\":{\"18\":1}}],[\"56\",{\"1\":{\"16\":1}}],[\"51\",{\"1\":{\"9\":1}}],[\"5\",{\"1\":{\"5\":1,\"9\":2,\"15\":2,\"49\":2}}],[\"46\",{\"1\":{\"10\":1}}],[\"4\",{\"0\":{\"17\":1},\"1\":{\"5\":4,\"9\":2,\"16\":2,\"49\":2}}],[\"3000\",{\"1\":{\"50\":1}}],[\"31\",{\"1\":{\"21\":2}}],[\"32\",{\"1\":{\"16\":1}}],[\"37\",{\"1\":{\"16\":1}}],[\"34\",{\"1\":{\"10\":1}}],[\"35\",{\"1\":{\"9\":1}}],[\"3\",{\"0\":{\"16\":1},\"1\":{\"5\":4,\"9\":2,\"19\":3,\"20\":2,\"49\":2}}],[\"200\",{\"1\":{\"52\":1}}],[\"2024\",{\"1\":{\"9\":1,\"10\":1}}],[\"2的hashcode为2\",{\"1\":{\"21\":1}}],[\"2n+1\",{\"1\":{\"21\":1}}],[\"24\",{\"1\":{\"12\":1}}],[\"2\",{\"0\":{\"9\":1,\"12\":1,\"15\":1},\"1\":{\"5\":6,\"9\":10,\"16\":2,\"18\":3,\"19\":2,\"20\":2,\"21\":2,\"49\":2}}],[\"1<<4\",{\"1\":{\"21\":1}}],[\"18\",{\"1\":{\"16\":1}}],[\"1994\",{\"1\":{\"16\":1}}],[\"1970\",{\"1\":{\"10\":1,\"15\":1}}],[\"10\",{\"1\":{\"15\":1,\"49\":2,\"54\":1}}],[\"1000\",{\"1\":{\"12\":4}}],[\"1235456\",{\"1\":{\"38\":1}}],[\"12\",{\"1\":{\"10\":2}}],[\"16\",{\"1\":{\"10\":1,\"21\":1,\"33\":1}}],[\"14686531l\",{\"1\":{\"10\":1}}],[\"15\",{\"1\":{\"9\":1}}],[\"1表示2月份\",{\"1\":{\"9\":1}}],[\"11111\",{\"1\":{\"35\":1}}],[\"111\",{\"1\":{\"35\":3}}],[\"11\",{\"1\":{\"5\":1,\"21\":1,\"35\":7}}],[\"1\",{\"0\":{\"8\":1,\"11\":1,\"14\":1},\"1\":{\"5\":3,\"9\":3,\"15\":2,\"16\":2,\"18\":1,\"19\":1,\"20\":2,\"21\":3,\"27\":1,\"32\":1,\"44\":1,\"49\":2,\"51\":2,\"69\":2,\"79\":3}}],[\"它有⼀个\",{\"1\":{\"29\":1}}],[\"它的\",{\"1\":{\"18\":1}}],[\"它的底层是一个动态数组\",{\"1\":{\"18\":1}}],[\"它的大小就是固定的\",{\"1\":{\"5\":1}}],[\"它提供了很多日历类型常见方法\",{\"1\":{\"7\":1}}],[\"它往往会影响\",{\"1\":{\"3\":1}}],[\"修饰符之后\",{\"1\":{\"79\":1}}],[\"修饰符\",{\"1\":{\"79\":1}}],[\"修饰方法\",{\"0\":{\"66\":1},\"1\":{\"72\":2}}],[\"修饰代码块\",{\"0\":{\"65\":1}}],[\"修饰\",{\"1\":{\"4\":1,\"21\":1}}],[\"修饰的实例变量\",{\"1\":{\"4\":1}}],[\"定义\",{\"1\":{\"4\":1}}],[\"定义一个带参数的构造器\",{\"1\":{\"4\":1}}],[\"定义一个\",{\"1\":{\"4\":1}}],[\"定义的枚举类默认继承了\",{\"1\":{\"4\":1}}],[\"星期几\",{\"1\":{\"9\":2}}],[\"星期六\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期五\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期四\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期三\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期二\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期一\",{\"1\":{\"4\":1,\"9\":1}}],[\"星期日\",{\"1\":{\"4\":1,\"9\":1}}],[\"带参数的构造函数\",{\"1\":{\"4\":1}}],[\"d+\",{\"1\":{\"79\":2}}],[\"droidyue\",{\"1\":{\"57\":1}}],[\"demo\",{\"1\":{\"74\":2}}],[\"default\",{\"1\":{\"74\":1}}],[\"deprecated\",{\"1\":{\"72\":1}}],[\"destroy\",{\"1\":{\"56\":1}}],[\"delete\",{\"1\":{\"34\":1,\"46\":1}}],[\"df6=datetimeformatter\",{\"1\":{\"17\":1}}],[\"df2=datetimeformatter\",{\"1\":{\"17\":1}}],[\"df1\",{\"1\":{\"17\":3}}],[\"duration\",{\"1\":{\"15\":1}}],[\"diff\",{\"1\":{\"12\":5}}],[\"day\",{\"1\":{\"9\":3,\"12\":2}}],[\"datetimeformatter\",{\"1\":{\"17\":3}}],[\"datetimeformatter格式化\",{\"0\":{\"17\":1}}],[\"date转格式化stirng\",{\"1\":{\"12\":1}}],[\"dateformat\",{\"1\":{\"12\":2}}],[\"date1\",{\"1\":{\"10\":2}}],[\"date2\",{\"1\":{\"10\":1}}],[\"date2=\",{\"1\":{\"10\":1}}],[\"date对象\",{\"0\":{\"10\":1}}],[\"date\",{\"1\":{\"4\":8,\"10\":8,\"11\":7,\"12\":5,\"15\":1,\"16\":2,\"17\":2}}],[\"d\",{\"1\":{\"4\":2,\"44\":4,\"79\":3}}],[\"dotall\",{\"1\":{\"79\":1}}],[\"document\",{\"1\":{\"73\":1}}],[\"do\",{\"1\":{\"3\":1}}],[\"global\",{\"1\":{\"79\":1}}],[\"group\",{\"1\":{\"79\":3}}],[\"green\",{\"1\":{\"4\":5}}],[\"g\",{\"1\":{\"79\":2}}],[\"genericreturntype=\",{\"1\":{\"77\":1}}],[\"genericparametertypes\",{\"1\":{\"77\":1}}],[\"genericparametertypes=mothed\",{\"1\":{\"77\":1}}],[\"genericparameterttpe\",{\"1\":{\"77\":3}}],[\"getannotation\",{\"1\":{\"78\":2}}],[\"getannotations\",{\"1\":{\"78\":1}}],[\"getactualtpyearguments\",{\"1\":{\"77\":1}}],[\"getgenericreturntype\",{\"1\":{\"77\":1}}],[\"getgenericparametertypes\",{\"1\":{\"77\":1}}],[\"getfields\",{\"1\":{\"76\":1}}],[\"getfirst\",{\"1\":{\"19\":1}}],[\"getdeclaredfield\",{\"1\":{\"76\":1}}],[\"getdeclaredfields\",{\"1\":{\"76\":1}}],[\"getdeclaredmothed\",{\"1\":{\"76\":1}}],[\"getdeclaredmotheds\",{\"1\":{\"76\":1}}],[\"getdeclaredconstructor\",{\"1\":{\"76\":1}}],[\"getdatepoor\",{\"1\":{\"12\":1}}],[\"getdate\",{\"1\":{\"4\":1}}],[\"getmotheds\",{\"1\":{\"76\":1}}],[\"getmothed\",{\"1\":{\"76\":1}}],[\"getconstructors\",{\"1\":{\"76\":1}}],[\"getclassloader\",{\"1\":{\"76\":1}}],[\"getclass\",{\"1\":{\"75\":1}}],[\"getinterfaces\",{\"1\":{\"76\":1}}],[\"getinstance\",{\"1\":{\"8\":1}}],[\"getsuperclass\",{\"1\":{\"76\":1}}],[\"getsimplename\",{\"1\":{\"76\":1}}],[\"getpriority\",{\"1\":{\"52\":1}}],[\"getname\",{\"1\":{\"46\":1,\"52\":1,\"76\":1}}],[\"getvalue\",{\"1\":{\"24\":1}}],[\"getkey\",{\"1\":{\"24\":1}}],[\"getlast\",{\"1\":{\"19\":1}}],[\"getxxxx\",{\"1\":{\"16\":1}}],[\"gettimeinmillis\",{\"1\":{\"11\":2}}],[\"gettime\",{\"1\":{\"11\":2,\"12\":3,\"15\":1}}],[\"gettype\",{\"1\":{\"4\":5}}],[\"get\",{\"1\":{\"4\":1,\"9\":7,\"11\":1,\"19\":1,\"22\":1,\"24\":1,\"51\":2,\"57\":1,\"60\":1}}],[\"god\",{\"1\":{\"55\":1}}],[\"guan\",{\"1\":{\"18\":1}}],[\"gc\",{\"1\":{\"18\":1}}],[\"抽象方法\",{\"1\":{\"4\":1}}],[\"+i+\",{\"1\":{\"49\":2}}],[\"+new\",{\"1\":{\"35\":1}}],[\"+1小时\",{\"1\":{\"15\":1}}],[\"+1\",{\"1\":{\"9\":1}}],[\"+calendar\",{\"1\":{\"9\":6}}],[\"+\",{\"1\":{\"4\":1,\"9\":1,\"12\":5,\"18\":1,\"21\":1,\"24\":10,\"31\":1,\"35\":2,\"79\":2}}],[\"也不给此分组分配组号\",{\"1\":{\"79\":1}}],[\"也会被清理掉\",{\"1\":{\"60\":1}}],[\"也是对回调模式的应用\",{\"1\":{\"29\":1}}],[\"也可接收runnable接口\",{\"1\":{\"51\":1}}],[\"也可\",{\"1\":{\"12\":1}}],[\"也可以包含抽象方法\",{\"1\":{\"4\":1}}],[\"也要考虑避免包含敏感信息\",{\"1\":{\"3\":1}}],[\"访问修饰符\",{\"1\":{\"4\":1}}],[\"f\",{\"1\":{\"79\":2}}],[\"functionalinterface\",{\"1\":{\"72\":1}}],[\"futuretask\",{\"1\":{\"51\":6}}],[\"futuretask的\",{\"1\":{\"51\":1}}],[\"futuretask即可接收callable接口\",{\"1\":{\"51\":1}}],[\"full\",{\"1\":{\"17\":2}}],[\"flags\",{\"1\":{\"79\":1}}],[\"flag\",{\"1\":{\"38\":1}}],[\"false\",{\"1\":{\"35\":3,\"37\":1}}],[\"file类\",{\"0\":{\"45\":1}}],[\"filewriter\",{\"1\":{\"44\":1}}],[\"filereader\",{\"1\":{\"44\":1}}],[\"fileoutputstream\",{\"1\":{\"44\":1}}],[\"fileinputstream\",{\"1\":{\"44\":1}}],[\"fill\",{\"1\":{\"5\":2}}],[\"field=clazz\",{\"1\":{\"76\":1}}],[\"field字段\",{\"1\":{\"73\":1}}],[\"field\",{\"1\":{\"11\":2,\"76\":4}}],[\"final\",{\"1\":{\"4\":4,\"31\":1,\"57\":1}}],[\"finally简洁版\",{\"1\":{\"3\":1}}],[\"finally\",{\"1\":{\"3\":1,\"44\":1}}],[\"fromindex\",{\"1\":{\"5\":1}}],[\"friday\",{\"1\":{\"4\":1}}],[\"forname\",{\"1\":{\"75\":1,\"76\":1}}],[\"foreach\",{\"1\":{\"18\":1,\"21\":1,\"24\":2}}],[\"formatter\",{\"1\":{\"57\":1}}],[\"formatstyle\",{\"1\":{\"17\":4}}],[\"format\",{\"1\":{\"12\":1,\"17\":1,\"32\":2}}],[\"for\",{\"1\":{\"4\":5,\"21\":1,\"24\":3,\"37\":1,\"49\":2,\"77\":1}}],[\"改变输出的值\",{\"1\":{\"4\":1}}],[\"不区分大小写\",{\"1\":{\"79\":1}}],[\"不包括空白符\",{\"1\":{\"79\":1}}],[\"不包括re\",{\"1\":{\"79\":1}}],[\"不包括ing\",{\"1\":{\"79\":1}}],[\"不受处理多行选项的影响\",{\"1\":{\"79\":1}}],[\"不捕获匹配的文本\",{\"1\":{\"79\":1}}],[\"不是元字符\",{\"1\":{\"79\":1}}],[\"不是线程安全的\",{\"1\":{\"12\":1}}],[\"不论通过哪一种方式获取的class对象都是同一个\",{\"1\":{\"75\":1}}],[\"不管\",{\"1\":{\"67\":1}}],[\"不管是文件读写还是网络发送接收\",{\"1\":{\"43\":1}}],[\"不会被清理\",{\"1\":{\"60\":1}}],[\"不会被分配\",{\"1\":{\"53\":1}}],[\"不会释放锁\",{\"1\":{\"52\":1}}],[\"不推荐使用jdk提供的停止线程方法\",{\"1\":{\"56\":1}}],[\"不推荐使用\",{\"1\":{\"52\":1}}],[\"不相同则利用链表在原结点后插入新的结点\",{\"1\":{\"27\":1}}],[\"不然会报\",{\"1\":{\"24\":1}}],[\"不可变保证了字符串本身是线程安全的\",{\"1\":{\"35\":1}}],[\"不可变\",{\"1\":{\"35\":1}}],[\"不可以对其进行添加元素操作\",{\"1\":{\"24\":1}}],[\"不可对其进行添加或者删除元素的操作\",{\"1\":{\"18\":1}}],[\"不能使用其修改集合相关的方法\",{\"1\":{\"18\":1}}],[\"不能直接创建对象\",{\"1\":{\"8\":1}}],[\"不要在\",{\"1\":{\"18\":1}}],[\"不要生吞\",{\"1\":{\"3\":1}}],[\"不允许重复\",{\"1\":{\"18\":1}}],[\"不存在的会报错\",{\"1\":{\"4\":1}}],[\"o\",{\"1\":{\"51\":2}}],[\"o流\",{\"0\":{\"40\":1}}],[\"obj为同步监视器\",{\"1\":{\"68\":1}}],[\"obj2\",{\"1\":{\"29\":1}}],[\"obj1\",{\"1\":{\"29\":1}}],[\"obj\",{\"1\":{\"29\":1,\"68\":1}}],[\"object\",{\"1\":{\"18\":1,\"19\":2,\"29\":3,\"76\":3}}],[\"object数组\",{\"1\":{\"18\":2}}],[\"oldcapacity\",{\"1\":{\"18\":1}}],[\"onehourlater\",{\"1\":{\"15\":1}}],[\"ofpattern\",{\"1\":{\"17\":1}}],[\"oflocalizeddatetime\",{\"1\":{\"17\":1}}],[\"ofhours\",{\"1\":{\"15\":1}}],[\"ofepochmilli\",{\"1\":{\"15\":1}}],[\"of\",{\"1\":{\"9\":3,\"16\":1,\"19\":1}}],[\"override\",{\"1\":{\"4\":3,\"49\":1,\"50\":3,\"51\":1,\"57\":1,\"72\":1}}],[\"ordinal\",{\"1\":{\"4\":2}}],[\"outputstream\",{\"1\":{\"42\":1}}],[\"out\",{\"1\":{\"3\":3,\"4\":6,\"9\":7,\"10\":2,\"21\":2,\"24\":4,\"35\":5,\"49\":2,\"51\":2}}],[\"v\",{\"1\":{\"24\":4,\"79\":2}}],[\"vector\",{\"1\":{\"18\":1}}],[\"value=retentionpolicy\",{\"1\":{\"73\":1}}],[\"value=\",{\"1\":{\"24\":3,\"73\":1}}],[\"value\",{\"1\":{\"11\":1,\"24\":1,\"60\":4}}],[\"valueof\",{\"1\":{\"4\":2,\"32\":1}}],[\"values是值的集合\",{\"1\":{\"24\":1}}],[\"values返回集合对象时\",{\"1\":{\"24\":1}}],[\"values\",{\"1\":{\"4\":3,\"24\":1}}],[\"void\",{\"1\":{\"3\":1,\"4\":6,\"11\":4,\"44\":2,\"48\":1,\"49\":2,\"50\":5,\"51\":1,\"76\":1}}],[\"两个接口\",{\"1\":{\"4\":1}}],[\"和get\",{\"1\":{\"57\":1}}],[\"和指定的泛型相同\",{\"1\":{\"51\":1}}],[\"和cas来操作\",{\"1\":{\"29\":1}}],[\"和加载因子\",{\"1\":{\"21\":1}}],[\"和\",{\"0\":{\"29\":1},\"1\":{\"4\":2,\"79\":2}}],[\"转义字符\",{\"1\":{\"79\":1}}],[\"转为\",{\"1\":{\"32\":1}}],[\"转成大写字母\",{\"1\":{\"32\":1}}],[\"转字符串\",{\"1\":{\"5\":1}}],[\"转化在内部类实现\",{\"1\":{\"4\":1}}],[\"转载\",{\"0\":{\"1\":1}}],[\"的全类名\",{\"1\":{\"76\":1}}],[\"的能力\",{\"1\":{\"74\":1}}],[\"的请求锁的时间\",{\"1\":{\"69\":1}}],[\"的弱引⽤\",{\"1\":{\"60\":1}}],[\"的特性可以使得\",{\"1\":{\"35\":1}}],[\"的时候已经摒弃了segment的概念\",{\"1\":{\"29\":1}}],[\"的时间值\",{\"1\":{\"11\":3}}],[\"的时间值进行设置\",{\"1\":{\"11\":2}}],[\"的hashcode\",{\"1\":{\"27\":1}}],[\"的⻓度\",{\"1\":{\"21\":1}}],[\"的位置也就是对应的数组下标\",{\"1\":{\"21\":1}}],[\"的本质就是只有键的\",{\"1\":{\"21\":1}}],[\"的stream\",{\"1\":{\"20\":1}}],[\"的数组\",{\"1\":{\"18\":1}}],[\"的空数组\",{\"1\":{\"18\":1}}],[\"的方式\",{\"1\":{\"18\":1}}],[\"的一个内部类\",{\"1\":{\"5\":1}}],[\"的\",{\"1\":{\"4\":1,\"11\":1,\"35\":2,\"59\":1,\"60\":2,\"68\":1}}],[\"每个对象都有一个monitor锁\",{\"1\":{\"67\":1}}],[\"每个线程都有自己threadlocalmap\",{\"1\":{\"59\":1}}],[\"每个线程都可以通过set\",{\"1\":{\"57\":1}}],[\"每个线程需要有自己单独的实例\",{\"1\":{\"58\":1}}],[\"每个\",{\"1\":{\"29\":1}}],[\"每个枚举都是通过\",{\"1\":{\"4\":1}}],[\"每⼀把锁只锁容器其中⼀部分数据\",{\"1\":{\"29\":1}}],[\"每实例化一个\",{\"1\":{\"3\":1}}],[\"枚举类的构造器只能使用\",{\"1\":{\"4\":1}}],[\"枚举既可以包含具体方法\",{\"1\":{\"4\":1}}],[\"枚举跟普通类一样可以用自己的变量\",{\"1\":{\"4\":1}}],[\"枚举值必须在枚举类的第一行显式地列出\",{\"1\":{\"4\":1}}],[\"枚举enum\",{\"0\":{\"4\":1}}],[\"在正则的哪里插入\",{\"1\":{\"79\":1}}],[\"在表达式里插记号的方式来启用绝大多数的模式\",{\"1\":{\"79\":1}}],[\"在一次程序运行过程中\",{\"1\":{\"75\":1}}],[\"在一位同乡挚友的鞭策下\",{\"1\":{\"0\":1}}],[\"在锁竞争激烈时\",{\"1\":{\"69\":1}}],[\"在方法的访问权限修饰符后\",{\"1\":{\"68\":1}}],[\"在同步代码块结束位置插入monitorexit\",{\"0\":{\"65\":1}}],[\"在垃圾回收的时候会被清理掉的\",{\"1\":{\"60\":1}}],[\"在堆中创建对象\",{\"1\":{\"35\":1}}],[\"在实体类中实现\",{\"1\":{\"29\":1}}],[\"在jdk1\",{\"1\":{\"29\":1}}],[\"在指定位置添加元素\",{\"1\":{\"19\":1}}],[\"在高并发情况下\",{\"1\":{\"18\":1}}],[\"在上⾯结构的基础上\",{\"1\":{\"18\":1}}],[\"在\",{\"1\":{\"12\":1,\"79\":2}}],[\"在内部实现的\",{\"1\":{\"4\":1}}],[\"在保证诊断信息足够的同时\",{\"1\":{\"3\":1}}],[\"作为异常设计者\",{\"1\":{\"3\":1}}],[\"multiline\",{\"1\":{\"79\":1}}],[\"multiple\",{\"1\":{\"3\":1}}],[\"m~n\",{\"1\":{\"79\":1}}],[\"m\",{\"1\":{\"79\":8}}],[\"more\",{\"1\":{\"79\":1}}],[\"mothed\",{\"1\":{\"76\":2,\"77\":1}}],[\"mothed=clazz\",{\"1\":{\"76\":1}}],[\"monitor\",{\"0\":{\"65\":2}}],[\"monitorenter\",{\"0\":{\"65\":1}}],[\"mon\",{\"1\":{\"10\":1}}],[\"month\",{\"1\":{\"9\":2,\"11\":1}}],[\"monday\",{\"1\":{\"4\":1}}],[\"method\",{\"1\":{\"76\":1}}],[\"meta\",{\"0\":{\"73\":1}}],[\"medium\",{\"1\":{\"17\":1}}],[\"mstringthreadlocal\",{\"1\":{\"57\":4}}],[\"msg2\",{\"1\":{\"32\":1}}],[\"msg1\",{\"1\":{\"32\":1}}],[\"mkdirs\",{\"1\":{\"46\":1}}],[\"mkdir\",{\"1\":{\"46\":1}}],[\"matches\",{\"1\":{\"39\":1,\"79\":1}}],[\"matcher\",{\"1\":{\"39\":1,\"79\":2}}],[\"map\",{\"1\":{\"18\":1,\"22\":6,\"24\":6,\"59\":1}}],[\"main方法默认为5\",{\"1\":{\"54\":1}}],[\"main线程\",{\"1\":{\"49\":1}}],[\"main\",{\"1\":{\"3\":1,\"4\":3,\"44\":2,\"49\":1,\"50\":1,\"51\":1}}],[\"mm\",{\"1\":{\"12\":1,\"17\":1}}],[\"ming\",{\"1\":{\"35\":2}}],[\"minusxxx\",{\"1\":{\"16\":1}}],[\"minusseconds\",{\"1\":{\"15\":1}}],[\"minute\",{\"1\":{\"9\":1}}],[\"min\",{\"1\":{\"12\":2}}],[\"millis\",{\"1\":{\"11\":1,\"14\":1}}],[\"millisec\",{\"1\":{\"10\":1}}],[\"myannotation的注解执行aop业务\",{\"1\":{\"74\":1}}],[\"myannotation\",{\"1\":{\"74\":2}}],[\"myarray2\",{\"1\":{\"20\":2}}],[\"myarray\",{\"1\":{\"20\":2}}],[\"mylist\",{\"1\":{\"20\":2}}],[\"myvar\",{\"1\":{\"4\":2}}],[\"myclass\",{\"1\":{\"4\":1}}],[\"|\",{\"1\":{\"3\":1,\"79\":1}}],[\"w匹配到的内容\",{\"1\":{\"79\":2}}],[\"w+\",{\"1\":{\"79\":7}}],[\"w\",{\"1\":{\"79\":7}}],[\"word\",{\"1\":{\"79\":1}}],[\"word中\",{\"1\":{\"67\":1}}],[\"world\",{\"1\":{\"3\":2,\"19\":1}}],[\"write\",{\"1\":{\"44\":2}}],[\"writer\",{\"1\":{\"42\":1}}],[\"while\",{\"1\":{\"18\":1,\"44\":2}}],[\"when\",{\"1\":{\"11\":2}}],[\"week\",{\"1\":{\"9\":1}}],[\"weekenum\",{\"1\":{\"4\":2}}],[\"wednesday\",{\"1\":{\"4\":1}}],[\"withxxx\",{\"1\":{\"16\":1}}],[\"with\",{\"1\":{\"3\":1,\"16\":1}}],[\"=ing\",{\"1\":{\"79\":1}}],[\"=50\",{\"1\":{\"50\":1}}],[\"=stringutils\",{\"1\":{\"38\":1}}],[\"==\",{\"1\":{\"35\":5}}],[\"==0\",{\"1\":{\"18\":1}}],[\"=datetimeformatter\",{\"1\":{\"17\":1}}],[\"=dateformat\",{\"1\":{\"12\":1}}],[\"=\",{\"1\":{\"3\":1,\"4\":8,\"5\":2,\"8\":1,\"10\":1,\"12\":12,\"14\":1,\"15\":9,\"16\":3,\"18\":5,\"20\":5,\"21\":2,\"35\":6,\"37\":1,\"39\":1,\"44\":14,\"49\":3,\"50\":1,\"51\":3,\"57\":2,\"77\":1,\"79\":4}}],[\"bw\",{\"1\":{\"44\":4}}],[\"bufferedwriter\",{\"1\":{\"44\":2}}],[\"bufferedoutputstream\",{\"1\":{\"44\":2}}],[\"bufferedinputstream\",{\"1\":{\"44\":2}}],[\"bufferedreader\",{\"1\":{\"3\":2,\"44\":2}}],[\"begin\",{\"1\":{\"32\":1}}],[\"before\",{\"1\":{\"11\":1,\"15\":1}}],[\"bos\",{\"1\":{\"44\":5}}],[\"boxed\",{\"1\":{\"20\":1}}],[\"boolean\",{\"1\":{\"11\":2,\"15\":2,\"37\":1,\"38\":1,\"39\":1,\"79\":1}}],[\"bao\",{\"1\":{\"18\":1}}],[\"bis\",{\"1\":{\"44\":5}}],[\"birthday\",{\"1\":{\"16\":1}}],[\"binarysearch\",{\"1\":{\"5\":1}}],[\"b\",{\"1\":{\"4\":2,\"20\":1,\"51\":1,\"79\":2}}],[\"blue\",{\"1\":{\"4\":8}}],[\"br\",{\"1\":{\"3\":1,\"44\":3}}],[\"elementtype\",{\"1\":{\"73\":1}}],[\"e1\",{\"1\":{\"50\":2}}],[\"equalsignorecase\",{\"1\":{\"32\":1}}],[\"equals\",{\"1\":{\"32\":1}}],[\"e>\",{\"1\":{\"19\":2}}],[\"emptylist\",{\"1\":{\"18\":1}}],[\"endswith\",{\"1\":{\"32\":1}}],[\"end\",{\"1\":{\"32\":1,\"34\":2}}],[\"enddate\",{\"1\":{\"12\":2}}],[\"entry<string\",{\"1\":{\"24\":1}}],[\"entry\",{\"1\":{\"24\":4}}],[\"entryset中的类型是map\",{\"1\":{\"24\":1}}],[\"entryset是\",{\"1\":{\"24\":1}}],[\"entryset\",{\"1\":{\"24\":2}}],[\"enum\",{\"1\":{\"4\":8,\"74\":1}}],[\"e\",{\"0\":{\"80\":1},\"1\":{\"3\":1,\"5\":1,\"44\":1,\"51\":2}}],[\"error\",{\"1\":{\"3\":1}}],[\"executors\",{\"1\":{\"51\":1}}],[\"exists\",{\"1\":{\"46\":1}}],[\"extends\",{\"1\":{\"3\":4,\"19\":2,\"49\":1,\"51\":1}}],[\"exception\",{\"1\":{\"3\":6,\"44\":2,\"51\":2}}],[\"r\",{\"1\":{\"79\":2}}],[\"runtime\",{\"1\":{\"73\":1}}],[\"runtimeexception\",{\"1\":{\"3\":1}}],[\"runtimeexception与其子类\",{\"1\":{\"3\":1}}],[\"runnable接口实现类对象\",{\"1\":{\"52\":2}}],[\"runnable\",{\"1\":{\"50\":3,\"51\":2}}],[\"run方法线程体\",{\"1\":{\"49\":1}}],[\"run\",{\"1\":{\"49\":1,\"50\":3}}],[\"re\",{\"1\":{\"79\":1}}],[\"retention\",{\"1\":{\"73\":1}}],[\"return\",{\"1\":{\"3\":1,\"4\":5,\"12\":1,\"37\":2,\"39\":1,\"51\":1,\"57\":1}}],[\"readline\",{\"1\":{\"44\":1}}],[\"read\",{\"1\":{\"44\":1}}],[\"reader\",{\"1\":{\"42\":1}}],[\"reverse\",{\"1\":{\"34\":1}}],[\"reverseorder\",{\"1\":{\"5\":1}}],[\"replace\",{\"1\":{\"32\":1,\"34\":1}}],[\"replaceall\",{\"1\":{\"32\":1}}],[\"removelast\",{\"1\":{\"19\":1}}],[\"removefirst\",{\"1\":{\"19\":1}}],[\"removeall\",{\"1\":{\"19\":1}}],[\"remove\",{\"1\":{\"18\":4,\"19\":2,\"22\":1,\"57\":1,\"60\":1}}],[\"red\",{\"1\":{\"4\":8}}],[\"resources会自动关闭流对象\",{\"1\":{\"3\":1}}],[\"非数字字符\",{\"1\":{\"79\":1}}],[\"非静态方法\",{\"1\":{\"52\":1,\"67\":1}}],[\"非检查异常\",{\"1\":{\"3\":1}}],[\"非法参数异常\",{\"1\":{\"3\":1}}],[\"如\",{\"1\":{\"18\":1,\"69\":1}}],[\"如果group栈非空匹配表达式yes\",{\"1\":{\"79\":1}}],[\"如果参数类型是泛型\",{\"1\":{\"77\":1}}],[\"如果此\",{\"1\":{\"76\":1}}],[\"如果只有一个参数成员\",{\"1\":{\"74\":1}}],[\"如果锁竞争太激烈\",{\"1\":{\"69\":1}}],[\"如果有多个线程竞争锁资源\",{\"1\":{\"69\":1}}],[\"如果在接下来的执行\",{\"1\":{\"69\":1}}],[\"如果两个字符串相同且后一个不是new\",{\"1\":{\"68\":1}}],[\"如果获取对象锁失败\",{\"0\":{\"65\":1}}],[\"如果不为null\",{\"1\":{\"44\":1}}],[\"如果一个对象只存在弱引用\",{\"1\":{\"60\":1}}],[\"如果一个\",{\"1\":{\"35\":1}}],[\"如果要操作少量的数据用\",{\"1\":{\"33\":1}}],[\"如果都没有找到\",{\"1\":{\"32\":1}}],[\"如果找不到\",{\"1\":{\"32\":1}}],[\"如果该对象代表的字符串在常量池可以找到\",{\"1\":{\"32\":1}}],[\"如果+号左右存在变量则调用的stringbuilder的\",{\"1\":{\"31\":1}}],[\"如果相同的话\",{\"1\":{\"27\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"27\":1}}],[\"如果暂时无法确定集合大小\",{\"1\":{\"21\":1}}],[\"如果并发操作\",{\"1\":{\"18\":1}}],[\"如果已满则自动扩容1\",{\"1\":{\"18\":1}}],[\"如果想用这三个类接收数据库日期\",{\"1\":{\"16\":1}}],[\"如果传入基本数据类型的数组\",{\"1\":{\"5\":1}}],[\"如果枚举类具有抽象方法\",{\"1\":{\"4\":1}}],[\"如果发生的非常频繁\",{\"1\":{\"3\":1}}],[\"如ioexception\",{\"1\":{\"3\":1}}],[\"编译器要求你必须处置的异常\",{\"1\":{\"3\":1}}],[\"类似$\",{\"1\":{\"79\":1}}],[\"类似^\",{\"1\":{\"79\":1}}],[\"类名\",{\"1\":{\"75\":1}}],[\"类锁\",{\"1\":{\"67\":1}}],[\"类不用实现接口\",{\"1\":{\"50\":1}}],[\"类返回的对象\",{\"1\":{\"18\":1}}],[\"类提供两个构造函数来实例化\",{\"1\":{\"10\":1}}],[\"类来封装当前的日期和时间\",{\"1\":{\"10\":1}}],[\"类中使⽤\",{\"1\":{\"31\":1}}],[\"类中\",{\"1\":{\"4\":1}}],[\"类\",{\"1\":{\"4\":1,\"18\":1,\"72\":1,\"76\":2}}],[\"类已加载但运行时找不到\",{\"1\":{\"3\":1}}],[\"类未找到\",{\"1\":{\"3\":1}}],[\"类转换异常\",{\"1\":{\"3\":1}}],[\"name\",{\"1\":{\"74\":1,\"76\":4}}],[\"native\",{\"1\":{\"48\":1}}],[\"n\",{\"1\":{\"21\":2,\"27\":2,\"32\":1,\"79\":11}}],[\"next\",{\"1\":{\"18\":1}}],[\"newinstance\",{\"1\":{\"76\":2}}],[\"newline\",{\"1\":{\"44\":1}}],[\"newtest\",{\"1\":{\"44\":2}}],[\"newcapacity=\",{\"1\":{\"18\":1}}],[\"new\",{\"1\":{\"3\":2,\"4\":3,\"5\":1,\"10\":2,\"12\":2,\"18\":3,\"19\":2,\"20\":1,\"21\":1,\"31\":1,\"35\":1,\"44\":8,\"49\":1,\"50\":10,\"51\":4,\"52\":2,\"57\":3,\"67\":1}}],[\"npe\",{\"1\":{\"18\":1}}],[\"ns\",{\"1\":{\"12\":2}}],[\"nm\",{\"1\":{\"12\":3}}],[\"nh\",{\"1\":{\"12\":4}}],[\"nd\",{\"1\":{\"12\":5}}],[\"node\",{\"1\":{\"29\":1}}],[\"nowdate\",{\"1\":{\"12\":2}}],[\"now\",{\"1\":{\"12\":2,\"15\":2,\"16\":2}}],[\"noclassdeffounderror\",{\"1\":{\"3\":1}}],[\"num\",{\"1\":{\"50\":1}}],[\"nums\",{\"1\":{\"5\":1}}],[\"nums1\",{\"1\":{\"5\":1}}],[\"nums0\",{\"1\":{\"5\":1}}],[\"null\",{\"1\":{\"18\":1,\"44\":6,\"60\":1,\"76\":1}}],[\"nullpointerexception\",{\"1\":{\"3\":1}}],[\"ignore\",{\"1\":{\"79\":1}}],[\"implements\",{\"1\":{\"50\":2,\"51\":1}}],[\"immutable\",{\"1\":{\"18\":1}}],[\"i++\",{\"1\":{\"49\":2}}],[\"if\",{\"1\":{\"18\":1,\"37\":1,\"44\":2,\"77\":1}}],[\"items\",{\"1\":{\"21\":3}}],[\"item\",{\"1\":{\"18\":1,\"21\":4}}],[\"iterator<string>\",{\"1\":{\"18\":1}}],[\"iterator\",{\"1\":{\"18\":7}}],[\"isalive\",{\"1\":{\"52\":1}}],[\"isafter\",{\"1\":{\"15\":1}}],[\"isfile\",{\"1\":{\"46\":1}}],[\"isdigit\",{\"1\":{\"37\":1}}],[\"isnumeric\",{\"1\":{\"37\":1,\"38\":1,\"39\":1}}],[\"isempty\",{\"1\":{\"18\":1,\"19\":1,\"32\":1}}],[\"iso\",{\"1\":{\"17\":1}}],[\"isbefore\",{\"1\":{\"15\":1}}],[\"i\",{\"0\":{\"40\":1},\"1\":{\"15\":1,\"19\":1,\"37\":3,\"49\":4,\"79\":2}}],[\"ioexception\",{\"1\":{\"3\":1,\"44\":1}}],[\"insensitive\",{\"1\":{\"79\":2}}],[\"instanceof\",{\"1\":{\"77\":1}}],[\"instant6\",{\"1\":{\"15\":4}}],[\"instant2\",{\"1\":{\"15\":1}}],[\"instant类表示一个具体的时刻可以精确到纳秒\",{\"1\":{\"15\":1}}],[\"instant\",{\"0\":{\"15\":1},\"1\":{\"14\":1,\"15\":15}}],[\"ing\",{\"1\":{\"79\":1}}],[\"invoke\",{\"1\":{\"76\":2}}],[\"initialvalue\",{\"1\":{\"57\":1}}],[\"initialcapacity\",{\"1\":{\"21\":2}}],[\"inputstream\",{\"1\":{\"42\":1}}],[\"indexof\",{\"1\":{\"19\":2,\"32\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"3\":1}}],[\"index\",{\"1\":{\"19\":2,\"32\":1}}],[\"introspect\",{\"1\":{\"74\":1}}],[\"interface\",{\"1\":{\"74\":2}}],[\"interface用来声明一个注解\",{\"1\":{\"74\":1}}],[\"interrupt\",{\"1\":{\"52\":1}}],[\"interruptedexception\",{\"1\":{\"3\":1,\"50\":1}}],[\"intern\",{\"1\":{\"32\":1,\"35\":2}}],[\"integer\",{\"1\":{\"20\":1,\"51\":3}}],[\"int\",{\"1\":{\"5\":4,\"11\":7,\"15\":1,\"16\":1,\"19\":1,\"20\":1,\"21\":1,\"32\":3,\"34\":4,\"37\":1,\"44\":1,\"49\":2,\"50\":1,\"52\":1}}],[\"illegalargumentexception\",{\"1\":{\"3\":1,\"4\":1}}],[\"算术异常\",{\"1\":{\"3\":1}}],[\"但尽可能少重复\",{\"1\":{\"79\":5}}],[\"但推荐使用共享资源\",{\"1\":{\"68\":1}}],[\"但是如果一系列的连续操作都对同一个\",{\"1\":{\"69\":1}}],[\"但是\",{\"1\":{\"60\":1}}],[\"但是要求传入第二个参数\",{\"1\":{\"29\":1}}],[\"但不受处理多行选项的影响\",{\"1\":{\"79\":2}}],[\"但不希望被多线程共享\",{\"1\":{\"58\":1}}],[\"但不会和其他线程的局\",{\"1\":{\"57\":1}}],[\"但字符流可以解决这样的问题\",{\"1\":{\"43\":1}}],[\"但字节流处理多个字节表示的东西的时候有可能会出现乱码的问题\",{\"1\":{\"43\":1}}],[\"但小于\",{\"1\":{\"18\":1}}],[\"但实际上是子类的对象\",{\"1\":{\"3\":1}}],[\"但我很少能够受他们所影响\",{\"1\":{\"0\":1}}],[\"输出结果\",{\"1\":{\"12\":1}}],[\"输出\",{\"1\":{\"3\":1,\"4\":2,\"9\":1,\"10\":1,\"49\":1,\"51\":1}}],[\"输出堆栈轨迹信息\",{\"1\":{\"3\":1}}],[\"hasnext\",{\"1\":{\"18\":1}}],[\"hashentry\",{\"1\":{\"29\":2}}],[\"hash判断当前元素存放的位置\",{\"1\":{\"27\":1}}],[\"hash值\",{\"1\":{\"27\":1}}],[\"hash\",{\"1\":{\"21\":2,\"27\":1,\"35\":2}}],[\"hash的值大约40亿个\",{\"1\":{\"21\":1}}],[\"hashtable\",{\"0\":{\"29\":1},\"1\":{\"18\":1,\"21\":2,\"29\":1}}],[\"hashmap的hash方法\",{\"1\":{\"27\":1}}],[\"hashmap底层实现\",{\"0\":{\"26\":1}}],[\"hashmap底层会通过tablesizefor\",{\"1\":{\"21\":1}}],[\"hashmap会根据key的hashcode\",{\"1\":{\"21\":1}}],[\"hashmap创建时默认的初始化容量\",{\"1\":{\"21\":1}}],[\"hashmap\",{\"1\":{\"18\":4,\"21\":4,\"27\":2,\"35\":1}}],[\"hashset判断对象是否存在\",{\"1\":{\"21\":1}}],[\"hashset\",{\"1\":{\"18\":2,\"21\":1}}],[\"hhmm\",{\"1\":{\"57\":1}}],[\"hh\",{\"1\":{\"12\":1,\"17\":1}}],[\"hour\",{\"1\":{\"9\":1,\"12\":2}}],[\"h\",{\"1\":{\"5\":2}}],[\"hello\",{\"1\":{\"3\":2,\"19\":1}}],[\"human\",{\"1\":{\"3\":1}}],[\"target\",{\"1\":{\"73\":1}}],[\"task\",{\"1\":{\"51\":1}}],[\"talkreceive\",{\"1\":{\"50\":2}}],[\"talksend\",{\"1\":{\"50\":2}}],[\"tk\",{\"1\":{\"50\":4}}],[\"ticket\",{\"1\":{\"50\":3}}],[\"timestamp\",{\"1\":{\"15\":1}}],[\"time\",{\"1\":{\"12\":2,\"17\":1}}],[\"time1\",{\"1\":{\"12\":2}}],[\"time包\",{\"0\":{\"13\":1},\"1\":{\"12\":1}}],[\"time库\",{\"1\":{\"12\":1}}],[\"txt\",{\"1\":{\"44\":5}}],[\"t\",{\"1\":{\"18\":1,\"76\":3,\"79\":2}}],[\"true\",{\"1\":{\"35\":2,\"37\":1,\"55\":1,\"76\":3}}],[\"trim\",{\"1\":{\"32\":1}}],[\"treemap\",{\"1\":{\"18\":1,\"29\":1}}],[\"treeset\",{\"1\":{\"18\":1,\"29\":1}}],[\"try\",{\"1\":{\"3\":6,\"44\":1,\"50\":1,\"51\":1}}],[\"tochararray\",{\"1\":{\"32\":1}}],[\"touppercase\",{\"1\":{\"32\":1}}],[\"toffset\",{\"1\":{\"32\":1}}],[\"tolist\",{\"1\":{\"20\":2}}],[\"toarray\",{\"1\":{\"18\":3}}],[\"toindex\",{\"1\":{\"5\":1}}],[\"tostring\",{\"1\":{\"4\":1,\"5\":1,\"31\":1}}],[\"tuesday\",{\"1\":{\"4\":1}}],[\"type类\",{\"1\":{\"73\":1}}],[\"type\",{\"1\":{\"4\":1,\"75\":1,\"77\":4}}],[\"thread=new\",{\"1\":{\"55\":1}}],[\"thread方法\",{\"0\":{\"52\":1}}],[\"thread\",{\"0\":{\"53\":1},\"1\":{\"49\":1,\"50\":7,\"51\":3,\"52\":5,\"55\":3}}],[\"threadlocal使用完后使用remove\",{\"1\":{\"61\":1}}],[\"threadlocalmap中使用这个\",{\"1\":{\"60\":1}}],[\"threadlocalmap获取属于自己的value\",{\"1\":{\"59\":1}}],[\"threadlocalmap\",{\"1\":{\"59\":1,\"60\":1}}],[\"threadlocal必须在使用完成后手动回收\",{\"1\":{\"57\":1}}],[\"threadlocal<simpledateformat>\",{\"1\":{\"57\":2}}],[\"threadlocal<string>\",{\"1\":{\"57\":1}}],[\"threadlocal<>\",{\"1\":{\"57\":1}}],[\"threadlocal创建的变量只能被当前线程访问\",{\"1\":{\"57\":1}}],[\"threadlocal\",{\"0\":{\"57\":1,\"58\":1,\"59\":1,\"60\":1},\"1\":{\"12\":1,\"59\":1,\"60\":3,\"61\":1}}],[\"throw\",{\"1\":{\"3\":2}}],[\"throws\",{\"1\":{\"3\":1,\"44\":2,\"51\":1}}],[\"thu\",{\"1\":{\"10\":1}}],[\"thursday\",{\"1\":{\"4\":1}}],[\"this\",{\"1\":{\"4\":3}}],[\"testthread\",{\"1\":{\"51\":5}}],[\"test\",{\"1\":{\"4\":2,\"44\":2,\"49\":5,\"51\":1}}],[\"aeiou\",{\"1\":{\"79\":1}}],[\"actualtpyearguments\",{\"1\":{\"77\":1}}],[\"acc\",{\"0\":{\"66\":1}}],[\"aspect\",{\"1\":{\"74\":1}}],[\"aslist\",{\"1\":{\"5\":2,\"18\":1,\"20\":1}}],[\"append\",{\"1\":{\"31\":1,\"34\":1}}],[\"annotation=clazz\",{\"1\":{\"78\":1}}],[\"annotation=field\",{\"1\":{\"78\":1}}],[\"annotations=\",{\"1\":{\"78\":1}}],[\"annotation\",{\"0\":{\"71\":1},\"1\":{\"74\":1,\"78\":2}}],[\"annoyance\",{\"1\":{\"3\":5}}],[\"and\",{\"1\":{\"24\":2}}],[\"addlast\",{\"1\":{\"19\":1}}],[\"addfirst\",{\"1\":{\"19\":1}}],[\"addall\",{\"1\":{\"19\":2}}],[\"add\",{\"1\":{\"18\":6,\"19\":2}}],[\"after\",{\"1\":{\"11\":1,\"15\":1}}],[\"abstract\",{\"1\":{\"4\":1}}],[\"arr\",{\"1\":{\"5\":1}}],[\"array1\",{\"1\":{\"5\":1}}],[\"arraylist如何动态扩容\",{\"1\":{\"18\":1}}],[\"arraylist<>\",{\"1\":{\"18\":2,\"20\":1,\"21\":1}}],[\"arraylist\",{\"1\":{\"5\":1,\"18\":2,\"19\":13}}],[\"arrays\",{\"1\":{\"5\":12,\"18\":1,\"20\":3}}],[\"array\",{\"1\":{\"5\":2,\"18\":2}}],[\"array=\",{\"1\":{\"5\":1}}],[\"array2=new\",{\"1\":{\"5\":1}}],[\"arithmeticexception\",{\"1\":{\"3\":1}}],[\"args\",{\"1\":{\"3\":1,\"4\":3,\"44\":2,\"49\":1,\"50\":1,\"51\":1}}],[\"a\",{\"1\":{\"3\":2,\"4\":2,\"5\":6,\"20\":1,\"51\":1,\"52\":1,\"79\":5}}],[\"p\",{\"1\":{\"79\":2}}],[\"pointcut\",{\"1\":{\"74\":1}}],[\"pool\",{\"1\":{\"35\":3}}],[\"parameterizedtype\",{\"1\":{\"77\":1}}],[\"parse\",{\"1\":{\"12\":1,\"15\":2,\"17\":1}}],[\"pattern\",{\"1\":{\"39\":4,\"79\":3}}],[\"protected\",{\"1\":{\"57\":1}}],[\"program\",{\"1\":{\"35\":2}}],[\"programming\",{\"1\":{\"35\":2}}],[\"prefix\",{\"1\":{\"32\":2}}],[\"private\",{\"1\":{\"4\":6,\"50\":1,\"57\":1}}],[\"println\",{\"1\":{\"3\":3,\"4\":6,\"9\":7,\"10\":2,\"21\":2,\"24\":4,\"35\":5,\"49\":2,\"51\":2}}],[\"printstacktrace\",{\"1\":{\"3\":1,\"50\":1,\"51\":1}}],[\"put\",{\"1\":{\"22\":1}}],[\"public\",{\"1\":{\"3\":1,\"4\":20,\"12\":1,\"37\":1,\"39\":1,\"44\":2,\"49\":3,\"50\":7,\"51\":4,\"74\":2}}],[\"plusxxx\",{\"1\":{\"16\":1}}],[\"plusminutes\",{\"1\":{\"15\":1}}],[\"plus\",{\"1\":{\"15\":2}}],[\"plushours\",{\"1\":{\"15\":1}}],[\"schools\",{\"1\":{\"74\":1}}],[\"sleep\",{\"1\":{\"50\":1,\"52\":1}}],[\"s6\",{\"1\":{\"35\":3}}],[\"s5\",{\"1\":{\"35\":2}}],[\"s4\",{\"1\":{\"35\":2}}],[\"s3\",{\"1\":{\"35\":2}}],[\"s就可以接受大部分数据\",{\"1\":{\"32\":1}}],[\"s2\",{\"1\":{\"32\":1,\"35\":4}}],[\"s1=new\",{\"1\":{\"35\":2}}],[\"s1\",{\"1\":{\"32\":1,\"35\":5}}],[\"suppresswarnings\",{\"1\":{\"72\":1}}],[\"suffix\",{\"1\":{\"32\":1}}],[\"substring\",{\"1\":{\"32\":1}}],[\"sunday\",{\"1\":{\"4\":1}}],[\"split\",{\"1\":{\"32\":1}}],[\"sale\",{\"1\":{\"50\":4}}],[\"san\",{\"1\":{\"22\":1}}],[\"saturday\",{\"1\":{\"4\":1}}],[\"synchronized标识\",{\"0\":{\"66\":1}}],[\"synchronized只锁定当前链表或红⿊⼆叉树的⾸节点\",{\"1\":{\"29\":1}}],[\"synchronized\",{\"0\":{\"63\":1,\"69\":1},\"1\":{\"21\":1,\"29\":2,\"68\":1}}],[\"system\",{\"1\":{\"3\":3,\"4\":6,\"9\":7,\"10\":2,\"21\":1,\"24\":3,\"35\":5,\"49\":2,\"51\":2}}],[\"short\",{\"1\":{\"17\":1}}],[\"ss\",{\"1\":{\"12\":1,\"17\":1}}],[\"si\",{\"1\":{\"22\":1}}],[\"singletonlist\",{\"1\":{\"18\":1}}],[\"simpledateformat\",{\"0\":{\"12\":1},\"1\":{\"12\":3,\"57\":2}}],[\"size\",{\"1\":{\"5\":1,\"18\":9,\"19\":1,\"22\":1}}],[\"source<class<\",{\"1\":{\"73\":1}}],[\"sort\",{\"1\":{\"5\":3,\"29\":1}}],[\"some\",{\"1\":{\"3\":1}}],[\"segment\",{\"1\":{\"29\":3}}],[\"sec\",{\"1\":{\"12\":1}}],[\"second\",{\"1\":{\"9\":1}}],[\"setaccessible\",{\"1\":{\"76\":3}}],[\"set为null\",{\"1\":{\"61\":1}}],[\"set的值\",{\"1\":{\"59\":1}}],[\"setdaemon\",{\"1\":{\"55\":1}}],[\"setdate\",{\"1\":{\"4\":1}}],[\"setpriority\",{\"1\":{\"52\":1}}],[\"set里面的类型即key的类型\",{\"1\":{\"24\":1}}],[\"settimeinmillis\",{\"1\":{\"11\":1}}],[\"settime\",{\"1\":{\"11\":1}}],[\"set\",{\"1\":{\"4\":1,\"11\":2,\"18\":1,\"19\":1,\"57\":1,\"60\":1,\"76\":1}}],[\"seriablizable\",{\"1\":{\"4\":1}}],[\"sqlexception等\",{\"1\":{\"3\":1}}],[\"s\",{\"0\":{\"80\":1},\"1\":{\"3\":1,\"32\":2,\"79\":8}}],[\"stop\",{\"1\":{\"56\":1}}],[\"state\",{\"0\":{\"53\":1}}],[\"static\",{\"1\":{\"3\":1,\"4\":7,\"12\":1,\"37\":1,\"39\":1,\"44\":2,\"49\":1,\"50\":1,\"51\":1,\"57\":1,\"76\":1}}],[\"start0\",{\"1\":{\"48\":1}}],[\"start\",{\"1\":{\"34\":2,\"49\":2,\"50\":6,\"51\":2,\"52\":1}}],[\"startswith\",{\"1\":{\"32\":3}}],[\"stirng方法\",{\"0\":{\"31\":1}}],[\"str=\",{\"1\":{\"35\":1,\"38\":1}}],[\"str\",{\"1\":{\"32\":2,\"34\":1,\"37\":3,\"38\":1,\"39\":2,\"44\":3}}],[\"stream\",{\"1\":{\"20\":2}}],[\"string比较\",{\"1\":{\"35\":1}}],[\"string不可变的好处\",{\"0\":{\"35\":1}}],[\"stringbuilder\",{\"1\":{\"33\":1}}],[\"stringbuilder方法\",{\"0\":{\"33\":1}}],[\"stringbuffer和stringbuilder是可变的\",{\"1\":{\"33\":1}}],[\"stringbuffer\",{\"0\":{\"33\":1},\"1\":{\"33\":1}}],[\"string和包装类都默认实现了\",{\"1\":{\"29\":1}}],[\"string>\",{\"1\":{\"24\":1}}],[\"string转日期\",{\"1\":{\"17\":1}}],[\"string转date\",{\"1\":{\"12\":1}}],[\"string\",{\"1\":{\"3\":1,\"4\":12,\"5\":2,\"12\":2,\"18\":3,\"21\":1,\"24\":2,\"31\":2,\"32\":5,\"33\":1,\"34\":2,\"35\":20,\"37\":1,\"38\":1,\"39\":1,\"44\":3,\"49\":1,\"50\":1,\"51\":1,\"74\":3,\"76\":2}}],[\"ststemutc\",{\"1\":{\"14\":1}}],[\"sneeze\",{\"1\":{\"3\":5}}],[\"swallow\",{\"1\":{\"3\":1}}],[\"cpu\",{\"1\":{\"53\":1}}],[\"currentthread\",{\"1\":{\"52\":1}}],[\"createnewfile\",{\"1\":{\"46\":1}}],[\"character\",{\"1\":{\"37\":1}}],[\"charat\",{\"1\":{\"32\":1,\"37\":1}}],[\"char\",{\"1\":{\"32\":1}}],[\"ch\",{\"1\":{\"32\":1}}],[\"checked\",{\"1\":{\"3\":1}}],[\"clazz\",{\"1\":{\"78\":1}}],[\"classloader\",{\"1\":{\"76\":1}}],[\"class类的方法\",{\"0\":{\"76\":1}}],[\"class字节码文件中\",{\"1\":{\"67\":1}}],[\"classnotfoundexception\",{\"1\":{\"3\":1}}],[\"classcastexception\",{\"1\":{\"3\":1}}],[\"class\",{\"1\":{\"3\":3,\"4\":5,\"49\":1,\"50\":3,\"51\":2,\"74\":1,\"75\":3,\"76\":7,\"78\":2}}],[\"close\",{\"1\":{\"44\":4}}],[\"clock获取指定时区的当前日期\",{\"1\":{\"14\":1}}],[\"clock\",{\"0\":{\"14\":1},\"1\":{\"14\":5,\"16\":1}}],[\"clear\",{\"1\":{\"18\":1,\"19\":1}}],[\"cst\",{\"1\":{\"10\":2}}],[\"c\",{\"1\":{\"4\":2,\"5\":1,\"19\":3,\"20\":1}}],[\"c2\",{\"1\":{\"4\":2}}],[\"comment\",{\"1\":{\"79\":1}}],[\"comments\",{\"1\":{\"79\":1}}],[\"com\",{\"1\":{\"57\":1,\"74\":1}}],[\"compile\",{\"1\":{\"39\":1,\"79\":1}}],[\"compare\",{\"1\":{\"29\":2}}],[\"compareto\",{\"1\":{\"15\":1,\"29\":2,\"32\":1}}],[\"comparator接⼝出⾃\",{\"1\":{\"29\":1}}],[\"comparable接⼝出⾃java\",{\"1\":{\"29\":1}}],[\"comparable\",{\"1\":{\"4\":1,\"29\":3}}],[\"copyofrange\",{\"1\":{\"5\":1}}],[\"copyof\",{\"1\":{\"5\":1}}],[\"collectors\",{\"1\":{\"20\":2}}],[\"collect\",{\"1\":{\"20\":2}}],[\"collection<\",{\"1\":{\"19\":3}}],[\"collection\",{\"1\":{\"18\":1}}],[\"collections\",{\"1\":{\"5\":1,\"18\":1,\"29\":1}}],[\"colorinfo\",{\"1\":{\"4\":4}}],[\"color\",{\"1\":{\"4\":22}}],[\"content\",{\"1\":{\"79\":1}}],[\"containsvalue\",{\"1\":{\"22\":1}}],[\"containskey\",{\"1\":{\"22\":1}}],[\"contains\",{\"1\":{\"5\":1,\"19\":1}}],[\"concat\",{\"1\":{\"32\":2}}],[\"concurrenthashmap\",{\"0\":{\"29\":1},\"1\":{\"29\":2}}],[\"connectorjava版本不能低于5\",{\"1\":{\"16\":1}}],[\"constructor=clazz\",{\"1\":{\"76\":1}}],[\"constructor\",{\"1\":{\"4\":4,\"76\":2}}],[\"c1\",{\"1\":{\"4\":5}}],[\"case\",{\"1\":{\"79\":2}}],[\"cas\",{\"1\":{\"69\":1}}],[\"capacity>>1\",{\"1\":{\"18\":1}}],[\"callable\",{\"1\":{\"51\":2}}],[\"callable<integer>\",{\"1\":{\"51\":1}}],[\"call\",{\"1\":{\"51\":3}}],[\"called\",{\"1\":{\"4\":4}}],[\"calendar\",{\"1\":{\"8\":3,\"9\":8,\"11\":6}}],[\"calendar是一个抽象类\",{\"1\":{\"8\":1}}],[\"calendar是java中常用的时间处理工具之一\",{\"1\":{\"7\":1}}],[\"calendar对象获取日历\",{\"0\":{\"7\":1}}],[\"caught\",{\"1\":{\"3\":4}}],[\"catch\",{\"1\":{\"3\":6,\"44\":1,\"50\":1,\"51\":1}}],[\"父类能够捕获子类异常\",{\"1\":{\"3\":1}}],[\"这适用于在短时间内持有锁\",{\"1\":{\"69\":1}}],[\"这是为了避免在同一线程重复获取同一把锁时\",{\"1\":{\"69\":1}}],[\"这是一个相对比较重的操作\",{\"1\":{\"3\":1}}],[\"这样才能提高synchronized同步锁的性能\",{\"1\":{\"69\":1}}],[\"这样一来就会出现\",{\"1\":{\"60\":1}}],[\"这样一\",{\"1\":{\"60\":1}}],[\"这样字节流就可以根据位数准确的读写汉字了\",{\"1\":{\"43\":1}}],[\"这样只要hash不冲突\",{\"1\":{\"29\":1}}],[\"这样的通用异常\",{\"1\":{\"3\":1}}],[\"这⾥的\",{\"1\":{\"27\":1}}],[\"这就解释了\",{\"1\":{\"21\":1}}],[\"这个时候就可能会产⽣内存泄露\",{\"1\":{\"60\":1}}],[\"这个操作代价很高\",{\"1\":{\"18\":1}}],[\"这个开销可就不能被忽略了\",{\"1\":{\"3\":1}}],[\"都会对当时的栈进行快照\",{\"1\":{\"3\":1}}],[\"join\",{\"1\":{\"52\":1}}],[\"jdk内置注解\",{\"0\":{\"72\":1}}],[\"jdk1\",{\"0\":{\"27\":1,\"28\":1},\"1\":{\"18\":4,\"27\":1,\"29\":1}}],[\"jdk8之后\",{\"1\":{\"21\":1}}],[\"jdk8之前\",{\"1\":{\"21\":1}}],[\"jdk8新增\",{\"0\":{\"13\":1}}],[\"jdk8将其引入并修改为java\",{\"1\":{\"12\":1}}],[\"jdk7提供的try\",{\"1\":{\"3\":1}}],[\"jan\",{\"1\":{\"10\":2}}],[\"java正则表达式中\",{\"1\":{\"79\":1}}],[\"java无法真正开启线程\",{\"1\":{\"48\":1}}],[\"java中的多线程和juc\",{\"0\":{\"47\":1}}],[\"java8\",{\"1\":{\"20\":1}}],[\"java\",{\"0\":{\"13\":1,\"80\":1,\"81\":1},\"1\":{\"3\":1,\"4\":4,\"5\":2,\"10\":1,\"29\":2,\"74\":1}}],[\"jvm在jdk\",{\"1\":{\"69\":1}}],[\"jvm会在字节码文件中方法标识符中添加一个\",{\"0\":{\"66\":1}}],[\"jvm会在字节码文件中在同步代码块开始位置插入\",{\"0\":{\"65\":1}}],[\"jvm将操作系统中的running运行中和ready就绪隐藏起来\",{\"1\":{\"53\":1}}],[\"jvm\",{\"1\":{\"3\":1}}],[\"尽量不要一个大的\",{\"1\":{\"3\":1}}],[\"尽量不要捕获类似\",{\"1\":{\"3\":1}}],[\"对unicode符大小写不敏感\",{\"1\":{\"79\":1}}],[\"对\",{\"1\":{\"79\":2}}],[\"对应的monitor锁\",{\"0\":{\"66\":1}}],[\"对整个桶\",{\"1\":{\"29\":1}}],[\"对的集合\",{\"1\":{\"24\":1}}],[\"对象反复加锁和解锁\",{\"1\":{\"69\":1}}],[\"对象锁\",{\"1\":{\"67\":1}}],[\"对象存在于每个java对象的对象头中\",{\"0\":{\"65\":1}}],[\"对象之间的\",{\"1\":{\"51\":1}}],[\"对象和\",{\"1\":{\"51\":1}}],[\"对象放入常量池\",{\"1\":{\"35\":1}}],[\"对象已经被创建过了\",{\"1\":{\"35\":1}}],[\"对象加锁\",{\"1\":{\"18\":1}}],[\"对象时就指定大概的容量大小\",{\"1\":{\"18\":1}}],[\"对象\",{\"1\":{\"10\":1,\"11\":1,\"35\":1,\"59\":2,\"75\":1,\"76\":3}}],[\"对象名为常量名\",{\"1\":{\"4\":1}}],[\"对代码进行优化\",{\"1\":{\"3\":1}}],[\"对以往的知识体系进行系统的回顾与记录\",{\"1\":{\"0\":1}}],[\"异常处理原则\",{\"0\":{\"3\":1}}],[\"异常用于解决一下程序无法掌握但又必须面对的情况\",{\"1\":{\"2\":1}}],[\"异常\",{\"0\":{\"2\":1},\"1\":{\"3\":1,\"18\":1,\"24\":1}}],[\"知识脑图\",{\"0\":{\"1\":1}}],[\"我们定义注解元素时\",{\"1\":{\"74\":1}}],[\"我们在编写代码的时\",{\"1\":{\"69\":1}}],[\"我们创建的变量是可以被任何一个线程访问并修改的\",{\"1\":{\"57\":1}}],[\"我们往往有充足信息进行分类\",{\"1\":{\"3\":1}}],[\"我才愿意抽出时间和精力\",{\"1\":{\"0\":1}}],[\"我不是一个能够静下心来踏踏实实做技术的人\",{\"1\":{\"0\":1}}],[\"虽然身边不乏有对技术沉迷且执着的人\",{\"1\":{\"0\":1}}],[\"技术栈\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
